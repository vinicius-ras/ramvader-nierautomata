<?xml version="1.0"?>
<doc>
    <assembly>
        <name>RAMvader</name>
    </assembly>
    <members>
        <member name="T:RAMvader.CodeInjection.CodeCaveArtifact`3">
            <summary>
               This class represents the artifacts that can be added to a code cave.
               Artifacts may include: byte sequences, addresses of injected variables, assembly instructions, etc.
               Futurely, new kinds of artifacts might be created for making the process of building of code caves easier,
               more flexible and more powerful.
               During the injection process, the <see cref="T:RAMvader.CodeInjection.Injector`3"/>
               will use the artifacts of each code cave to build the byte codes of each one of the code caves that need to be
               injected.
            </summary>
        </member>
        <member name="F:RAMvader.CodeInjection.CodeCaveArtifact`3.m_injector">
            <summary>This field is set to a reference of the injector</summary>
        </member>
        <member name="M:RAMvader.CodeInjection.CodeCaveArtifact`3.LockWithInjector(RAMvader.CodeInjection.Injector{`0,`1,`2})">
            <summary>
               <para>
                  Sets the <see cref="T:RAMvader.CodeInjection.Injector`3"/> instance which is currently using
                  the <see cref="T:RAMvader.CodeInjection.CodeCaveArtifact`3"/> instance.
                  This method should be called only by the <see cref="T:RAMvader.CodeInjection.Injector`3"/>,
                  during the injection process.
               </para>
               <para>ATTENTION: This method is currently NOT thread safe.</para>
            </summary>
            <param name="injectorRef">A reference to the injector wich will be using this instance.</param>
            <exception cref="T:System.InvalidOperationException">
               Thrown when this instance is already locked by an <see cref="T:RAMvader.CodeInjection.Injector`3"/>,
               which hasn't called ReleaseFromInjector yet in order to release the instance to be used by
               another <see cref="T:RAMvader.CodeInjection.Injector`3"/>.
            </exception>
        </member>
        <member name="M:RAMvader.CodeInjection.CodeCaveArtifact`3.GetLockingInjector">
            <summary>
               Retrieves the <see cref="T:RAMvader.CodeInjection.Injector`3"/> instance that is currently
               locking this object, during an injection procedure.
            </summary>
            <returns>
               Returns the <see cref="T:RAMvader.CodeInjection.Injector`3"/> which is trying to inject
               the <see cref="T:RAMvader.CodeInjection.CodeCaveArtifact`3"/> instance.
            </returns>
        </member>
        <member name="M:RAMvader.CodeInjection.CodeCaveArtifact`3.ReleaseFromInjector">
            <summary>
               Releases this instance from the <see cref="T:RAMvader.CodeInjection.Injector`3"/> that is
               currently using it. During the injection process, the <see cref="T:RAMvader.CodeInjection.Injector`3"/>
               that needs to use a <see cref="T:RAMvader.CodeInjection.CodeCaveArtifact`3"/> locks it for its
               own use, and after the injection it releases it by calling this method, allowing other <see cref="T:RAMvader.CodeInjection.Injector`3"/>s
               to lock and use this instance.
            </summary>
            <exception cref="T:System.InvalidOperationException">
               Thrown when there are currently no <see cref="T:RAMvader.CodeInjection.Injector`3"/> instance
               locking the object.
            </exception>
        </member>
        <member name="M:RAMvader.CodeInjection.CodeCaveArtifact`3.GenerateArtifactBytes">
            <summary>
               Generates the bytes which correspond to the artifact instance.
               These bytes are the ones to be actually written to the target process' memory space by
               the <see cref="T:RAMvader.CodeInjection.Injector`3"/>
               during the injection procedure.
            </summary>
            <returns>
               Returns an array of bytes corresponding to the artifact when it is injected in the target
               process' memory space.
            </returns>
        </member>
        <member name="M:RAMvader.CodeInjection.CodeCaveArtifact`3.GetTotalSize(RAMvader.RAMvaderTarget)">
            <summary>Retrieves the total size of a given artifact, in bytes.</summary>
            <param name="target">
               The instance of <see cref="T:RAMvader.RAMvaderTarget"/> that is setup to access the target process' memory space.
               This instance is used to know properties of the target process, such as its pointers size.
            </param>
            <returns>Returns the total size of the artifact, in bytes.</returns>
        </member>
        <member name="T:RAMvader.CodeInjection.CodeCaveArtifactCodeCaveAddress`3">
            <summary>
               Specialization of the <see cref="T:RAMvader.CodeInjection.CodeCaveArtifact`3"/> class used to add the address
               of an injected code cave to a code cave.
            </summary>
        </member>
        <member name="F:RAMvader.CodeInjection.CodeCaveArtifactCodeCaveAddress`3.m_codeCaveId">
            <summary>The identifier of the code cave to be added through this artifact.</summary>
        </member>
        <member name="M:RAMvader.CodeInjection.CodeCaveArtifactCodeCaveAddress`3.#ctor(`1)">
            <summary>Constructor.</summary>
            <param name="codeCaveId">The identifier of the code cave to be added through this artifact.</param>
        </member>
        <member name="M:RAMvader.CodeInjection.CodeCaveArtifactCodeCaveAddress`3.GenerateArtifactBytes">
            <summary>
               Generates the bytes which correspond to the artifact instance.
               These bytes are the ones to be actually written to the target process' memory space by
               the <see cref="T:RAMvader.CodeInjection.Injector`3"/>
               during the injection procedure.
            </summary>
            <returns>
               Returns an array of bytes corresponding to the artifact when it is injected in the target
               process' memory space.
            </returns>
        </member>
        <member name="M:RAMvader.CodeInjection.CodeCaveArtifactCodeCaveAddress`3.GetTotalSize(RAMvader.RAMvaderTarget)">
            <summary>Retrieves the total size of a given artifact, in bytes.</summary>
            <param name="target">
               The instance of <see cref="T:RAMvader.RAMvaderTarget"/> that is setup to access the target process' memory space.
               This instance is used to know properties of the target process, such as its pointers size.
            </param>
            <returns>Returns the total size of the artifact, in bytes.</returns>
        </member>
        <member name="T:RAMvader.CodeInjection.CodeCaveArtifactX86Call`3">
            <summary>
               Specialization of the <see cref="T:RAMvader.CodeInjection.CodeCaveArtifact`3"/> class used to add
               a CALL instruction to a code cave.
            </summary>
        </member>
        <member name="F:RAMvader.CodeInjection.CodeCaveArtifactX86Call`3.m_targetCallAddress">
            <summary>The target address to where the call will be made.</summary>
        </member>
        <member name="M:RAMvader.CodeInjection.CodeCaveArtifactX86Call`3.#ctor(RAMvader.MemoryAddress)">
            <summary>Constructor.</summary>
            <param name="targetCallAddress">The address to be CALLed.</param>
        </member>
        <member name="M:RAMvader.CodeInjection.CodeCaveArtifactX86Call`3.GenerateArtifactBytes">
            <summary>
               Generates the bytes which correspond to the artifact instance.
               These bytes are the ones to be actually written to the target process' memory space by
               the <see cref="T:RAMvader.CodeInjection.Injector`3"/>
               during the injection procedure.
            </summary>
            <returns>
               Returns an array of bytes corresponding to the artifact when it is injected in the target
               process' memory space.
            </returns>
        </member>
        <member name="M:RAMvader.CodeInjection.CodeCaveArtifactX86Call`3.GetTotalSize(RAMvader.RAMvaderTarget)">
            <summary>Retrieves the total size of a given artifact, in bytes.</summary>
            <param name="target">
               The instance of <see cref="T:RAMvader.RAMvaderTarget"/> that is setup to access the target process' memory space.
               This instance is used to know properties of the target process, such as its pointers size.
            </param>
            <returns>Returns the total size of the artifact, in bytes.</returns>
        </member>
        <member name="T:RAMvader.CodeInjection.CodeCaveArtifactX86FarJump`3">
            <summary>
               Specialization of the <see cref="T:RAMvader.CodeInjection.CodeCaveArtifact`3"/> class used to add
               a FAR JUMP instruction to a code cave.
            </summary>
        </member>
        <member name="F:RAMvader.CodeInjection.CodeCaveArtifactX86FarJump`3.m_jumpInstructionType">
            <summary>The type of jump instruction to be generated.</summary>
        </member>
        <member name="F:RAMvader.CodeInjection.CodeCaveArtifactX86FarJump`3.m_targetJumpAddress">
            <summary>The target address to where the jump will be made.</summary>
        </member>
        <member name="M:RAMvader.CodeInjection.CodeCaveArtifactX86FarJump`3.#ctor(RAMvader.EJumpInstructionType,RAMvader.MemoryAddress)">
            <summary>Constructor.</summary>
            <param name="jumpInstructionType">The specific type of jump instruction to be generated.</param>
            <param name="targetJumpAddress">The address to which the JUMP instruction should jump.</param>
        </member>
        <member name="M:RAMvader.CodeInjection.CodeCaveArtifactX86FarJump`3.GenerateArtifactBytes">
            <summary>
               Generates the bytes which correspond to the artifact instance.
               These bytes are the ones to be actually written to the target process' memory space by
               the <see cref="T:RAMvader.CodeInjection.Injector`3"/>
               during the injection procedure.
            </summary>
            <returns>
               Returns an array of bytes corresponding to the artifact when it is injected in the target
               process' memory space.
            </returns>
        </member>
        <member name="M:RAMvader.CodeInjection.CodeCaveArtifactX86FarJump`3.GetTotalSize(RAMvader.RAMvaderTarget)">
            <summary>Retrieves the total size of a given artifact, in bytes.</summary>
            <param name="target">
               The instance of <see cref="T:RAMvader.RAMvaderTarget"/> that is setup to access the target process' memory space.
               This instance is used to know properties of the target process, such as its pointers size.
            </param>
            <returns>Returns the total size of the artifact, in bytes.</returns>
        </member>
        <member name="T:RAMvader.CodeInjection.CodeCaveArtifactX86NearJump`3">
            <summary>
               Specialization of the <see cref="T:RAMvader.CodeInjection.CodeCaveArtifact`3"/> class used to add
               a NEAR JUMP instruction to a code cave.
            </summary>
        </member>
        <member name="F:RAMvader.CodeInjection.CodeCaveArtifactX86NearJump`3.m_jumpInstructionType">
            <summary>The type of jump instruction to be generated.</summary>
        </member>
        <member name="F:RAMvader.CodeInjection.CodeCaveArtifactX86NearJump`3.m_targetJumpAddress">
            <summary>The target address to where the jump will be made.</summary>
        </member>
        <member name="M:RAMvader.CodeInjection.CodeCaveArtifactX86NearJump`3.#ctor(RAMvader.EJumpInstructionType,RAMvader.MemoryAddress)">
            <summary>Constructor.</summary>
            <param name="jumpInstructionType">The specific type of jump instruction to be generated.</param>
            <param name="targetJumpAddress">The address to which the JUMP instruction should jump.</param>
        </member>
        <member name="M:RAMvader.CodeInjection.CodeCaveArtifactX86NearJump`3.GenerateArtifactBytes">
            <summary>
               Generates the bytes which correspond to the artifact instance.
               These bytes are the ones to be actually written to the target process' memory space by
               the <see cref="T:RAMvader.CodeInjection.Injector`3"/>
               during the injection procedure.
            </summary>
            <returns>
               Returns an array of bytes corresponding to the artifact when it is injected in the target
               process' memory space.
            </returns>
        </member>
        <member name="M:RAMvader.CodeInjection.CodeCaveArtifactX86NearJump`3.GetTotalSize(RAMvader.RAMvaderTarget)">
            <summary>Retrieves the total size of a given artifact, in bytes.</summary>
            <param name="target">
               The instance of <see cref="T:RAMvader.RAMvaderTarget"/> that is setup to access the target process' memory space.
               This instance is used to know properties of the target process, such as its pointers size.
            </param>
            <returns>Returns the total size of the artifact, in bytes.</returns>
        </member>
        <member name="T:RAMvader.CodeInjection.CodeCaveArtifactSignedBytesSequence`3">
            <summary>
               Specialization of the <see cref="T:RAMvader.CodeInjection.CodeCaveArtifact`3"/> class used to add raw, signed bytes
               to a code cave.
            </summary>
        </member>
        <member name="F:RAMvader.CodeInjection.CodeCaveArtifactSignedBytesSequence`3.m_bytes">
            <summary>The raw bytes to be added through this artifact.</summary>
        </member>
        <member name="M:RAMvader.CodeInjection.CodeCaveArtifactSignedBytesSequence`3.#ctor(System.SByte[])">
            <summary>Constructor.</summary>
            <param name="bytes">The raw bytes to be added through this artifact.</param>
        </member>
        <member name="M:RAMvader.CodeInjection.CodeCaveArtifactSignedBytesSequence`3.GenerateArtifactBytes">
            <summary>
               Generates the bytes which correspond to the artifact instance.
               These bytes are the ones to be actually written to the target process' memory space by
               the <see cref="T:RAMvader.CodeInjection.Injector`3"/>
               during the injection procedure.
            </summary>
            <returns>
               Returns an array of bytes corresponding to the artifact when it is injected in the target
               process' memory space.
            </returns>
        </member>
        <member name="M:RAMvader.CodeInjection.CodeCaveArtifactSignedBytesSequence`3.GetTotalSize(RAMvader.RAMvaderTarget)">
            <summary>Retrieves the total size of a given artifact, in bytes.</summary>
            <param name="target">
               The instance of <see cref="T:RAMvader.RAMvaderTarget"/> that is setup to access the target process' memory space.
               This instance is used to know properties of the target process, such as its pointers size.
            </param>
            <returns>Returns the total size of the artifact, in bytes.</returns>
        </member>
        <member name="T:RAMvader.CodeInjection.CodeCaveArtifactUnsignedBytesSequence`3">
            <summary>
               Specialization of the <see cref="T:RAMvader.CodeInjection.CodeCaveArtifact`3"/> class used to add raw, unsigned bytes
               to a code cave.
            </summary>
        </member>
        <member name="F:RAMvader.CodeInjection.CodeCaveArtifactUnsignedBytesSequence`3.m_bytes">
            <summary>The raw bytes to be added through this artifact.</summary>
        </member>
        <member name="M:RAMvader.CodeInjection.CodeCaveArtifactUnsignedBytesSequence`3.#ctor(System.Byte[])">
            <summary>Constructor.</summary>
            <param name="bytes">The raw bytes to be added through this artifact.</param>
        </member>
        <member name="M:RAMvader.CodeInjection.CodeCaveArtifactUnsignedBytesSequence`3.GenerateArtifactBytes">
            <summary>
               Generates the bytes which correspond to the artifact instance.
               These bytes are the ones to be actually written to the target process' memory space by
               the <see cref="T:RAMvader.CodeInjection.Injector`3"/>
               during the injection procedure.
            </summary>
            <returns>
               Returns an array of bytes corresponding to the artifact when it is injected in the target
               process' memory space.
            </returns>
        </member>
        <member name="M:RAMvader.CodeInjection.CodeCaveArtifactUnsignedBytesSequence`3.GetTotalSize(RAMvader.RAMvaderTarget)">
            <summary>Retrieves the total size of a given artifact, in bytes.</summary>
            <param name="target">
               The instance of <see cref="T:RAMvader.RAMvaderTarget"/> that is setup to access the target process' memory space.
               This instance is used to know properties of the target process, such as its pointers size.
            </param>
            <returns>Returns the total size of the artifact, in bytes.</returns>
        </member>
        <member name="T:RAMvader.CodeInjection.CodeCaveArtifactVariableAddress`3">
            <summary>
               Specialization of the <see cref="T:RAMvader.CodeInjection.CodeCaveArtifact`3"/> class used to add the address
               of an injected variable to a code cave.
            </summary>
        </member>
        <member name="F:RAMvader.CodeInjection.CodeCaveArtifactVariableAddress`3.m_varId">
            <summary>The identifier of the variable to be added through this artifact.</summary>
        </member>
        <member name="M:RAMvader.CodeInjection.CodeCaveArtifactVariableAddress`3.#ctor(`2)">
            <summary>Constructor.</summary>
            <param name="varId">The identifier of the variable to be added through this artifact.</param>
        </member>
        <member name="M:RAMvader.CodeInjection.CodeCaveArtifactVariableAddress`3.GenerateArtifactBytes">
            <summary>
               Generates the bytes which correspond to the artifact instance.
               These bytes are the ones to be actually written to the target process' memory space by
               the <see cref="T:RAMvader.CodeInjection.Injector`3"/>
               during the injection procedure.
            </summary>
            <returns>
               Returns an array of bytes corresponding to the artifact when it is injected in the target
               process' memory space.
            </returns>
        </member>
        <member name="M:RAMvader.CodeInjection.CodeCaveArtifactVariableAddress`3.GetTotalSize(RAMvader.RAMvaderTarget)">
            <summary>Retrieves the total size of a given artifact, in bytes.</summary>
            <param name="target">
               The instance of <see cref="T:RAMvader.RAMvaderTarget"/> that is setup to access the target process' memory space.
               This instance is used to know properties of the target process, such as its pointers size.
            </param>
            <returns>Returns the total size of the artifact, in bytes.</returns>
        </member>
        <member name="T:RAMvader.CodeInjection.CodeCaveBuilder`3">
            <summary>
               <para>
                  A class specialized in building <see cref="T:RAMvader.CodeInjection.CodeCaveDefinition`3"/> objects.
                  This class follows a fluid design pattern, allowing calls to its code cave construction-related methods to
                  be cascaded, making code easier to read and maintain.
               </para>
               <para>
                  Under the hoods, this class generates <see cref="T:RAMvader.CodeInjection.CodeCaveArtifact`3"/> objects,
                  which are kept in a list that can be used to generate the code cave definition.
               </para>
               <para>
               </para>
            </summary>
        </member>
        <member name="F:RAMvader.CodeInjection.CodeCaveBuilder`3.m_injector">
            <summary>
               A reference to the <see cref="T:RAMvader.CodeInjection.Injector`3"/> object to which
               the <see cref="T:RAMvader.CodeInjection.CodeCaveDefinition`3"/> objects will be created.
            </summary>
        </member>
        <member name="F:RAMvader.CodeInjection.CodeCaveBuilder`3.m_artifacts">
            <summary>The list of artifacts that have currently been generated by the <see cref="T:RAMvader.CodeInjection.CodeCaveBuilder`3"/>.</summary>
        </member>
        <member name="M:RAMvader.CodeInjection.CodeCaveBuilder`3.#ctor(RAMvader.CodeInjection.Injector{`0,`1,`2})">
            <summary>Constructor.</summary>
            <param name="injector">
               A reference to the <see cref="T:RAMvader.CodeInjection.Injector`3"/> object to which
               the <see cref="T:RAMvader.CodeInjection.CodeCaveDefinition`3"/> objects will be created.
            </param>
        </member>
        <member name="M:RAMvader.CodeInjection.CodeCaveBuilder`3.Build">
            <summary>
               Called as the last step for building a <see cref="T:RAMvader.CodeInjection.CodeCaveDefinition`3"/>,
               returning the produced definition.
            </summary>
            <returns>Returns the created <see cref="T:RAMvader.CodeInjection.CodeCaveDefinition`3"/> instance.</returns>
        </member>
        <member name="M:RAMvader.CodeInjection.CodeCaveBuilder`3.VarAddr(`2)">
            <summary>
               Adds the bytes that represent the address of an injected code cave to the code cave being built.
               This effectivelly adds a <see cref="T:RAMvader.CodeInjection.CodeCaveArtifactVariableAddress`3"/>
               artifact to the list of generated artifacts.
            </summary>
            <param name="varId">The identifier of the variable whose address will be added.</param>
            <returns>Returns a reference to the object used to call the method.</returns>
        </member>
        <member name="M:RAMvader.CodeInjection.CodeCaveBuilder`3.CaveAddr(`1)">
            <summary>
               Adds the bytes that represent the address of an injected variable to the code cave being built.
               This effectivelly adds a <see cref="T:RAMvader.CodeInjection.CodeCaveArtifactCodeCaveAddress`3"/>
               artifact to the list of generated artifacts.
            </summary>
            <param name="caveId">The identifier of the code cave whose address will be added.</param>
            <returns>Returns a reference to the object used to call the method.</returns>
        </member>
        <member name="M:RAMvader.CodeInjection.CodeCaveBuilder`3.SBytes(System.SByte[])">
            <summary>
               Adds the given sequence of signed bytes (<see cref="T:System.SByte"/>) to the code cave being built.
               This effectivelly adds a <see cref="T:RAMvader.CodeInjection.CodeCaveArtifactSignedBytesSequence`3"/>
               artifact to the list of generated artifacts.
            </summary>
            <param name="bytes">The sequence of (signed) bytes which will be added.</param>
            <returns>Returns a reference to the object used to call the method.</returns>
        </member>
        <member name="M:RAMvader.CodeInjection.CodeCaveBuilder`3.Bytes(System.Byte[])">
            <summary>
               Adds the given sequence of unsigned bytes (<see cref="T:System.Byte"/>) to the code cave being built.
               This effectivelly adds a <see cref="T:RAMvader.CodeInjection.CodeCaveArtifactUnsignedBytesSequence`3"/>
               artifact to the list of generated artifacts.
            </summary>
            <param name="bytes">The sequence of (unsigned) bytes which will be added.</param>
            <returns>Returns a reference to the object used to call the method.</returns>
        </member>
        <member name="M:RAMvader.CodeInjection.CodeCaveBuilder`3.X86Call(RAMvader.MemoryAddress)">
            <summary>
               Adds the bytes corresponding to a CALL instruction to the code cave being built.
               This effectivelly adds a <see cref="T:RAMvader.CodeInjection.CodeCaveArtifactX86Call`3"/>
               artifact to the list of generated artifacts.
            </summary>
            <param name="targetAddress">The address to be CALLed.</param>
            <returns>Returns a reference to the object used to call the method.</returns>
        </member>
        <member name="M:RAMvader.CodeInjection.CodeCaveBuilder`3.X86NearJump(RAMvader.EJumpInstructionType,RAMvader.MemoryAddress)">
            <summary>
               Adds the bytes corresponding to a NEAR JUMP instruction to the code cave being built.
               This effectivelly adds a <see cref="T:RAMvader.CodeInjection.CodeCaveArtifactX86NearJump`3"/>
               artifact to the list of generated artifacts.
            </summary>
            <param name="jumpInstructionType">The specific type of jump instruction to be generated.</param>
            <param name="targetAddress">The address to which the instruction will jump.</param>
            <returns>Returns a reference to the object used to call the method.</returns>
        </member>
        <member name="M:RAMvader.CodeInjection.CodeCaveBuilder`3.X86FarJump(RAMvader.EJumpInstructionType,RAMvader.MemoryAddress)">
            <summary>
               Adds the bytes corresponding to a FAR JUMP instruction to the code cave being built.
               This effectivelly adds a <see cref="T:RAMvader.CodeInjection.CodeCaveArtifactX86FarJump`3"/>
               artifact to the list of generated artifacts.
            </summary>
            <param name="jumpInstructionType">The specific type of jump instruction to be generated.</param>
            <param name="targetAddress">The address to which the instruction will jump.</param>
            <returns>Returns a reference to the object used to call the method.</returns>
        </member>
        <member name="T:RAMvader.CodeInjection.CodeCaveDefinition`3">
            <summary>
               This class holds the definition of a Code Cave that can be injected into a process' memory space
               by using the <see cref="T:RAMvader.CodeInjection.Injector`3"/>.
               A code cave is made up of a list of <see cref="T:RAMvader.CodeInjection.CodeCaveArtifact`3"/> objects,
               which hold all the information used by the <see cref="T:RAMvader.CodeInjection.Injector`3"/> to
               generate the bytes of the code cave, which are then injected into the target process' memory space.
            </summary>
        </member>
        <member name="F:RAMvader.CodeInjection.CodeCaveDefinition`3.m_codeCaveArtifacts">
            <summary>The artifacts that compose the code cave.</summary>
        </member>
        <member name="M:RAMvader.CodeInjection.CodeCaveDefinition`3.#ctor">
            <summary>Constructor.</summary>
        </member>
        <member name="M:RAMvader.CodeInjection.CodeCaveDefinition`3.SetArtifactsArray(RAMvader.CodeInjection.CodeCaveArtifact{`0,`1,`2}[])">
            <summary>
               Allows you to manually set the <see cref="T:RAMvader.CodeInjection.CodeCaveArtifact`3"/> objects
               to be used to generate the code cave.
               Code caves are usually created by using a <see cref="T:RAMvader.CodeInjection.CodeCaveBuilder`3"/>,
               which is the recommended way. This method can be used as an alternative to using the builder approach.
            </summary>
            <param name="artifacts">The array containing the artifacts that will be used to generate the code cave.</param>
        </member>
        <member name="M:RAMvader.CodeInjection.CodeCaveDefinition`3.GetArtifactsArray">
            <summary>
               Retrieves the array of <see cref="T:RAMvader.CodeInjection.CodeCaveArtifact`3"/> objects used to
               generate the code cave.
            </summary>
            <returns>Returns the array of artifacts used to generate the code cave.</returns>
        </member>
        <member name="M:RAMvader.CodeInjection.CodeCaveDefinition`3.GenerateCodeCaveBytes(RAMvader.CodeInjection.Injector{`0,`1,`2})">
            <summary>
               <para>
                  Processes the list of <see cref="T:RAMvader.CodeInjection.CodeCaveArtifact`3"/> objects that
                  define the code cave, and generates the bytes that represent the code cave, as it should be injected in the target process'
                  memory space.
               </para>
               <para>
                  This method should be called by the <see cref="T:RAMvader.CodeInjection.Injector`3"/>
                  during the code injection process only.
               </para>
            </summary>
            <param name="injector">The <see cref="T:RAMvader.CodeInjection.Injector`3"/> object used to retrieve the bytes of the code cave.</param>
            <returns>Returns a byte sequence representing the code cave, ready to be injected into the game's memory.</returns>
        </member>
        <member name="M:RAMvader.CodeInjection.CodeCaveDefinition`3.GetCodeCaveSize(RAMvader.RAMvaderTarget)">
            <summary>Calculates and retrieves the size of the code cave.</summary>
            <param name="target">
               The instance of <see cref="T:RAMvader.RAMvaderTarget"/> that is setup to access the target process' memory space.
               This instance is used to know properties of the target process, such as its pointers size.
            </param>
            <returns>Returns the number of bytes of size for the code cave.</returns>
        </member>
        <member name="T:RAMvader.CodeInjection.IllegalInstructionGenerationException">
            <summary>
               Exception thrown when an instruction cannot be generated, because the generated instruction would be illegal.
               An example of that is trying to generate an X86 NEAR JUMP instruction that would try to perform a jump larger than
               the maximum value of a byte, which is impossible.
            </summary>
        </member>
        <member name="M:RAMvader.CodeInjection.IllegalInstructionGenerationException.#ctor(System.String)">
            <summary>Constructor.</summary>
            <param name="msg">The message to be associated with the exception.</param>
        </member>
        <member name="T:RAMvader.CodeInjection.InjectionArtifactNotFoundException">
            <summary>
               Exception thrown whenever an operation fails to find an injection artifact (which includes injection
               variables and code caves).
            </summary>
        </member>
        <member name="M:RAMvader.CodeInjection.InjectionArtifactNotFoundException.#ctor(System.String)">
            <summary>Constructor.</summary>
            <param name="msg">The message to be associated with the exception.</param>
        </member>
        <member name="T:RAMvader.CodeInjection.InjectorGenericParametersException">
            <summary>
               Exception thrown when trying to instantiate an <see cref="T:RAMvader.CodeInjection.Injector`3"/>
               whose generic parameters are illegal for some reason.
               All <see cref="T:RAMvader.CodeInjection.Injector`3"/>'s generic parameters should be enumerations.
            </summary>
        </member>
        <member name="M:RAMvader.CodeInjection.InjectorGenericParametersException.#ctor(System.String)">
            <summary>Constructor.</summary>
            <param name="msg">The message to be associated with the exception.</param>
        </member>
        <member name="T:RAMvader.CodeInjection.InstanceAlreadyInjectedException">
            <summary>
               Exception thrown when a method that requires the <see cref="T:RAMvader.CodeInjection.Injector`3"/> instance
               to be in "NOT injected" state, but this condition is not met.
               The <see cref="T:RAMvader.CodeInjection.Injector`3"/> is put in "injected" state when a call
               to <see cref="M:RAMvader.CodeInjection.Injector`3.Inject"/>
               or <see cref="M:RAMvader.CodeInjection.Injector`3.Inject(RAMvader.MemoryAddress)"/> is made.
            </summary>
        </member>
        <member name="M:RAMvader.CodeInjection.InstanceAlreadyInjectedException.#ctor">
            <summary>Constructor.</summary>
        </member>
        <member name="T:RAMvader.CodeInjection.InstanceNotInjectedException">
            <summary>
               Exception thrown when a method that requires the <see cref="T:RAMvader.CodeInjection.Injector`3"/> instance
               to be in "injected" state, but this condition is not met.
               The <see cref="T:RAMvader.CodeInjection.Injector`3"/> is put in "injected" state when a call
               to <see cref="M:RAMvader.CodeInjection.Injector`3.Inject"/>
               or <see cref="M:RAMvader.CodeInjection.Injector`3.Inject(RAMvader.MemoryAddress)"/> is made.
            </summary>
        </member>
        <member name="M:RAMvader.CodeInjection.InstanceNotInjectedException.#ctor">
            <summary>Constructor.</summary>
        </member>
        <member name="T:RAMvader.CodeInjection.InstructionTooLargeException">
            <summary>
               Exception thrown when the <see cref="T:RAMvader.CodeInjection.Injector`3"/> tries
               to generate an instruction whose size (in bytes) is larger than the space given for the generation of that instruction.
            </summary>
        </member>
        <member name="M:RAMvader.CodeInjection.InstructionTooLargeException.#ctor(System.Int32,System.Int32)">
            <summary>Constructor.</summary>
            <param name="givenSize">The size given for the instruction to be generated.</param>
            <param name="requiredSize">The size that is actually required to generate the instruction.</param>
        </member>
        <member name="T:RAMvader.CodeInjection.UnmatchedDataTypeException">
            <summary>
               Exception thrown when trying to perform an operation involving injection variables, and the data type used
               is different from the data type of the injection variable.
               Read/write operations on injection variables must ALWAYS match the exact type declared for the injection variable.
            </summary>
        </member>
        <member name="M:RAMvader.CodeInjection.UnmatchedDataTypeException.#ctor(System.Type,System.Type,System.Enum)">
            <summary>Constructor.</summary>
            <param name="givenType">The incorrect type used in the operation wich was tried against the injection variable.</param>
            <param name="requiredType">The actual type of the injection variable, which was required for the operation to succeed.</param>
            <param name="variableID">The identifier of the variable.</param>
        </member>
        <member name="T:RAMvader.CodeInjection.UnsupportedInstructionGenerationException">
            <summary>
               Exception thrown when the <see cref="T:RAMvader.CodeInjection.Injector`3"/> is unable
               to generate a given instruction, for some reason.
            </summary>
        </member>
        <member name="M:RAMvader.CodeInjection.UnsupportedInstructionGenerationException.#ctor(System.String)">
            <summary>Constructor.</summary>
            <param name="msg">The message to be associated with the exception.</param>
        </member>
        <member name="T:RAMvader.CodeInjection.VirtualMemoryAllocationException">
            <summary>An exception thrown by the <see cref="M:RAMvader.CodeInjection.Injector`3.Inject"/> method
            to indicate that it was unable to allocate virtual memory in the target process' memory space.</summary>
        </member>
        <member name="M:RAMvader.CodeInjection.VirtualMemoryAllocationException.#ctor">
            <summary>Constructor.</summary>
        </member>
        <member name="T:RAMvader.CodeInjection.Injector`3">
            <summary>
               Implements the logic behind the injection of code caves and variables into a target process' memory space.
            </summary>
            <typeparam name="TMemoryAlterationSetID">
               An enumerated type which specifies the identifiers for Memory Alteration Sets
               that can be enabled or disabled into the target process' memory space.
            </typeparam>
            <typeparam name="TCodeCave">An enumerated type which specifies the identifiers for code caves.</typeparam>
            <typeparam name="TVariable">
               An enumerated type which specifies the identifiers for variables to be injected at the
               target process.
            </typeparam>
        </member>
        <member name="F:RAMvader.CodeInjection.Injector`3.m_targetProcess">
            <summary>
               The object used to attach to the target process, so that the <see cref="T:RAMvader.CodeInjection.Injector`3"/> can
               perform I/O operations into the target process' memory.
            </summary>
        </member>
        <member name="F:RAMvader.CodeInjection.Injector`3.m_baseInjectionAddress">
            <summary>Keeps the base address of the memory which was allocated for the target process.</summary>
        </member>
        <member name="F:RAMvader.CodeInjection.Injector`3.m_currentInjectionOffset">
            <summary>
               Keeps track of how many bytes have been generated by the <see cref="T:RAMvader.CodeInjection.Injector`3"/>
               during an injection procedure.
            </summary>
        </member>
        <member name="F:RAMvader.CodeInjection.Injector`3.m_isInjected">
            <summary>Backs the <see cref="P:RAMvader.CodeInjection.Injector`3.IsInjected"/> property.</summary>
        </member>
        <member name="F:RAMvader.CodeInjection.Injector`3.m_bHasAllocatedMemory">
            <summary>
               A flag specifying if the <see cref="T:RAMvader.CodeInjection.Injector`3"/> has allocated memory in the target process for
               injecting its data. When the <see cref="T:RAMvader.CodeInjection.Injector`3"/> allocates memory in the target process, it is
               responsible for freing it whenever necessary.
            </summary>
        </member>
        <member name="F:RAMvader.CodeInjection.Injector`3.m_codeCavesSeparator">
            <summary>The sequence of bytes which separate two consecutive code caves.</summary>
        </member>
        <member name="F:RAMvader.CodeInjection.Injector`3.m_variablesSectionSeparator">
            <summary>The sequence of bytes which separate the code caves region from the variables region.</summary>
        </member>
        <member name="F:RAMvader.CodeInjection.Injector`3.m_memoryAlterationSets">
            <summary>Keeps all the alterations registered for a given memory alteration set.</summary>
        </member>
        <member name="F:RAMvader.CodeInjection.Injector`3.m_codeCaveOffset">
            <summary>
               Indexer field used to access the code cave offsets, usually for WPF Binding purposes.
               Calls <see cref="M:RAMvader.CodeInjection.Injector`3.GetCodeCaveOffset(`1)"/> internally.
            </summary>
        </member>
        <member name="F:RAMvader.CodeInjection.Injector`3.m_injectedCodeCaveAddress">
            <summary>
               Indexer property used to access the address where a code cave has been injected, usually
               for WPF Binding purposes. Calls <see cref="M:RAMvader.CodeInjection.Injector`3.GetInjectedCodeCaveAddress(`1)"/> internally.
            </summary>
        </member>
        <member name="F:RAMvader.CodeInjection.Injector`3.m_variableOffset">
            <summary>
               Indexer property used to access variable offsets, usually for WPF Binding purposes.
               Calls <see cref="M:RAMvader.CodeInjection.Injector`3.GetVariableOffset(`2)"/> internally.
            </summary>
        </member>
        <member name="F:RAMvader.CodeInjection.Injector`3.m_injectedVariableAddress">
            <summary>
               Indexer property used to access the address where a variable has been injected, usually
               for WPF Binding purposes. Calls <see cref="M:RAMvader.CodeInjection.Injector`3.GetInjectedVariableAddress(`2)"/> internally.
            </summary>
        </member>
        <member name="F:RAMvader.CodeInjection.Injector`3.m_variableSize">
            <summary>
               Indexer property used to retrieve the size of a variable, usually for WPF Binding purposes.
               Calls <see cref="M:RAMvader.CodeInjection.Injector`3.GetVariableSize(`2)"/> internally.
            </summary>
        </member>
        <member name="F:RAMvader.CodeInjection.Injector`3.m_codeCaveDefinitions">
            <summary>
               Maps each code cave identifier (<typeparamref name="TCodeCave"/>) to
               the object that holds its definition (<see cref="T:RAMvader.CodeInjection.CodeCaveDefinition`3"/>).
            </summary>
        </member>
        <member name="F:RAMvader.CodeInjection.Injector`3.m_variableDefinitions">
            <summary>
               Maps each injection variable identifier (<typeparamref name="TVariable"/>) to
               the object that holds its definition (<see cref="T:RAMvader.CodeInjection.VariableDefinition"/>).
            </summary>
        </member>
        <member name="P:RAMvader.CodeInjection.Injector`3.BaseInjectionAddress">
            <summary>
               Keeps the base address of the memory which was allocated for the target process.
               Backed by the <see cref="F:RAMvader.CodeInjection.Injector`3.m_baseInjectionAddress"/> field.
            </summary>
        </member>
        <member name="P:RAMvader.CodeInjection.Injector`3.IsInjected">
            <summary>
               A flag that is set to true whenever the <see cref="M:RAMvader.CodeInjection.Injector`3.Inject"/> (or <see cref="M:RAMvader.CodeInjection.Injector`3.Inject(RAMvader.MemoryAddress)"/>) method is called and succeeds, and set to false
               whenever the<see cref="M:RAMvader.CodeInjection.Injector`3.ResetAllocatedMemoryData"/> gets called.
            </summary>
        </member>
        <member name="P:RAMvader.CodeInjection.Injector`3.TargetProcess">
            <summary>
               The object used to attach to the target process, so that the <see cref="T:RAMvader.CodeInjection.Injector`3"/> can
               perform I/O operations into the target process' memory.
               Backed by the <see cref="F:RAMvader.CodeInjection.Injector`3.m_targetProcess"/> field.
            </summary>
        </member>
        <member name="P:RAMvader.CodeInjection.Injector`3.RequiredBytesCount">
            <summary>
               The total number of required bytes to inject the code caves and variables into the target
               process' memory space, as calculated by a call to the method <see cref="M:RAMvader.CodeInjection.Injector`3.CalculateRequiredBytesCount"/>.
            </summary>
        </member>
        <member name="P:RAMvader.CodeInjection.Injector`3.CodeCaveOffset">
            <summary>
               Indexer property used to access the code cave offsets, usually for WPF Binding purposes.
               Calls <see cref="M:RAMvader.CodeInjection.Injector`3.GetCodeCaveOffset(`1)"/> internally.
               Backed by the <see cref="F:RAMvader.CodeInjection.Injector`3.m_codeCaveOffset"/> field.
            </summary>
        </member>
        <member name="P:RAMvader.CodeInjection.Injector`3.InjectedCodeCaveAddress">
            <summary>
               Indexer property used to access the address where a code cave has been injected, usually
               for WPF Binding purposes. Calls <see cref="M:RAMvader.CodeInjection.Injector`3.GetInjectedCodeCaveAddress(`1)"/> internally.
               Backed by the <see cref="F:RAMvader.CodeInjection.Injector`3.m_injectedCodeCaveAddress"/> field.
            </summary>
        </member>
        <member name="P:RAMvader.CodeInjection.Injector`3.VariableOffset">
            <summary>
               Indexer property used to access variable offsets, usually for WPF Binding purposes.
               Calls <see cref="M:RAMvader.CodeInjection.Injector`3.GetVariableOffset(`2)"/> internally.
               Backed by the <see cref="F:RAMvader.CodeInjection.Injector`3.m_variableOffset"/> field.
            </summary>
        </member>
        <member name="P:RAMvader.CodeInjection.Injector`3.InjectedVariableAddress">
            <summary>
               Indexer property used to access the address where a variable has been injected, usually for WPF Binding purposes.
               Calls <see cref="M:RAMvader.CodeInjection.Injector`3.GetInjectedVariableAddress(`2)"/> internally.
               Backed by the <see cref="F:RAMvader.CodeInjection.Injector`3.m_injectedVariableAddress"/> field.
            </summary>
        </member>
        <member name="P:RAMvader.CodeInjection.Injector`3.VariableSize">
            <summary>
               Indexer property used to retrieve the size of a variable, usually for WPF Binding purposes.
               Calls <see cref="M:RAMvader.CodeInjection.Injector`3.GetVariableSize(`2)"/> internally.
               Backed by the <see cref="F:RAMvader.CodeInjection.Injector`3.m_variableSize"/> field.
            </summary>
        </member>
        <member name="M:RAMvader.CodeInjection.Injector`3.GetInjectorNameWithTemplateParameters">
            <summary>
               Utility method for retrieving a human-readable name for the <see cref="T:RAMvader.CodeInjection.Injector`3"/> class,
               including the name of its generic parameters.
            </summary>
            <returns>Returns a string containing the name of the <see cref="T:RAMvader.CodeInjection.Injector`3"/> class and its generic parameters.</returns>
        </member>
        <member name="M:RAMvader.CodeInjection.Injector`3.GetX86CallOpcode(RAMvader.MemoryAddress,RAMvader.MemoryAddress,System.Int32,RAMvader.EEndianness,RAMvader.EPointerSize,RAMvader.EDifferentPointerSizeError)">
            <summary>
               Utility method for retrieving a sequence of bytes which represent the machine-level opcode corresponding to a 32-bits CALL instruction.
               64-bits CALL instructions are currently not supported by the RAMvader library.
            </summary>
            <param name="callInstructionAddress">The address of the CALL instruction itself.</param>
            <param name="targetCallAddress">The address which should be called by the CALL instruction.</param>
            <param name="instructionSize">
               When replacing an instruction in a target process' memory space by a CALL instruction, this parameter specifies
               the size of the instruction to be replaced. If this size is larger than the size of a CALL instruction, the
               remaining bytes are filled with NOP opcodes in the returned bytes sequence, so that the CALL instruction might
               replace other instructions while keeping the consistency of its surrounding instructions when a RET instruction is used
               to return from the CALL.
            </param>
            <param name="endianness">The endianness to be used for the offset of the CALL opcode.</param>
            <param name="pointerSize">The size of pointer to be used for the offset of the CALL opcode.</param>
            <param name="diffPointerSizeError">
               The policy for handling errors regarding different sizes of pointers between RAMvader process' pointers and the pointers
               size defined by the "pointerSize" parameter.
            </param>
            <returns>Returns a sequence of bytes representing the CALL opcode that composes the given instruction.</returns>
            <exception cref="T:RAMvader.CodeInjection.InstructionTooLargeException">Thrown when the given instruction size is less than the size required to generate the instruction.</exception>
        </member>
        <member name="M:RAMvader.CodeInjection.Injector`3.GetX86NearJumpOpcode(RAMvader.EJumpInstructionType,RAMvader.MemoryAddress,RAMvader.MemoryAddress,System.Int32,RAMvader.EPointerSize)">
            <summary>
               Utility method for retrieving a sequence of bytes which represent the machine-level opcode corresponding
               to a 32-bits NEAR JUMP instruction. 64-bits JUMP instructions are currently not supported by the RAMvader library.
            </summary>
            <param name="jumpInstructionType">The specific type of jump instruction to be generated.</param>
            <param name="jumpInstructionAddress">The address of the JUMP instruction itself.</param>
            <param name="targetJumpAddress">The address to which the JUMP instruction should jump.</param>
            <param name="instructionSize">
               When replacing an instruction in a target process' memory space by a JUMP instruction, this parameter specifies the
               size of the instruction to be replaced. If this size is larger than the size of a JUMP instruction, the remaining bytes
               are filled with NOP opcodes in the returned bytes sequence, so that the JUMP instruction might replace other instructions
               while keeping the consistency of its surrounding instructions when the flow of code returns from the jump (if that ever
               happens).
            </param>
            <param name="pointerSize">The size of pointer to be used for the offset of the JUMP opcode.</param>
            <returns>Returns a sequence of bytes representing the JUMP opcode that composes the given instruction.</returns>
            <exception cref="T:RAMvader.CodeInjection.IllegalInstructionGenerationException">Thrown when the instruction cannot be generated, because the generated instruction would be illegal.</exception>
            <exception cref="T:RAMvader.CodeInjection.InstructionTooLargeException">Thrown when the given instruction size is less than the size required to generate the instruction.</exception>
        </member>
        <member name="M:RAMvader.CodeInjection.Injector`3.GetX86FarJumpOpcode(RAMvader.EJumpInstructionType,RAMvader.MemoryAddress,RAMvader.MemoryAddress,System.Int32,RAMvader.EEndianness,RAMvader.EPointerSize,RAMvader.EDifferentPointerSizeError)">
            <summary>
               Utility method for retrieving a sequence of bytes which represent the machine-level opcode
               corresponding to a x86 FAR JUMP instruction. 64-bits JUMP instructions are currently not supported
               by the RAMvader library.
            </summary>
            <param name="jumpInstructionType">The specific type of jump instruction to be generated.</param>
            <param name="jumpInstructionAddress">The address of the JUMP instruction itself.</param>
            <param name="targetJumpAddress">The address to which the JUMP instruction should jump.</param>
            <param name="instructionSize">
               When replacing an instruction in a target process' memory space by a JUMP instruction, this parameter specifies
               the size of the instruction to be replaced. If this size is larger than the size of a JUMP instruction, the
               remaining bytes are filled with NOP opcodes in the returned bytes sequence, so that the JUMP instruction might
               replace other instructions while keeping the consistency of its surrounding instructions when the flow of code
               returns from the jump (if that ever happens).
            </param>
            <param name="endianness">The endianness to be used for the offset of the JUMP opcode.</param>
            <param name="pointerSize">The size of pointer to be used for the offset of the JUMP opcode.</param>
            <param name="diffPointerSizeError">
               The policy for handling errors regarding different sizes of pointers between RAMvader process' pointers and the
               pointers size defined by the "pointerSize" parameter.
            </param>
            <returns>Returns a sequence of bytes representing the JUMP opcode that composes the given instruction.</returns>
            <exception cref="T:RAMvader.CodeInjection.IllegalInstructionGenerationException">Thrown when the instruction cannot be generated, because the generated instruction would be illegal.</exception>
            <exception cref="T:RAMvader.CodeInjection.InstructionTooLargeException">Thrown when the given instruction size is less than the size required to generate the instruction.</exception>
        </member>
        <member name="M:RAMvader.CodeInjection.Injector`3.#ctor">
            <summary>
               Constructor. The constructor of the <see cref="T:RAMvader.CodeInjection.Injector`3"/> class checks the code caves and
               variables for consistency, throwing an exception if there is any error found.
            </summary>
            <exception cref="T:RAMvader.UnsupportedDataTypeException">
               Thrown if any of the injection variables (enumerators of the type <typeparamref name="TVariable"/>) has
               a data type that is not supported by the RAMvader library.
            </exception>
            <exception cref="T:RAMvader.CodeInjection.InjectorGenericParametersException">
               Thrown in cases where there are any errors with the generic types defined for the <see cref="T:RAMvader.CodeInjection.Injector`3"/>.
               The types <typeparamref name="TMemoryAlterationSetID"/>, <typeparamref name="TCodeCave"/> and <typeparamref name="TVariable"/> MUST be enumerations.
            </exception>
        </member>
        <member name="M:RAMvader.CodeInjection.Injector`3.SetTargetProcess(RAMvader.RAMvaderTarget)">
            <summary>
               Initializes or modifies the reference to the object used by the <see cref="T:RAMvader.CodeInjection.Injector`3"/>
               to perform write operations to the target process' memory. The <see cref="T:RAMvader.CodeInjection.Injector`3"/>
               also uses this object to know the endianness and pointer size of the target process.
            </summary>
            <param name="targetProc">The object used for performing memory I/O operations on the target process.</param>
            <seealso cref="M:RAMvader.CodeInjection.Injector`3.GetTargetProcess"/>
        </member>
        <member name="M:RAMvader.CodeInjection.Injector`3.GetTargetProcess">
            <summary>
               Retrieves the current reference to the object used by the <see cref="T:RAMvader.CodeInjection.Injector`3"/> to
               perform write operations to the target process' memory.
               The <see cref="T:RAMvader.CodeInjection.Injector`3"/> also uses this object to know the endianness and pointer
               size of the target process.
            </summary>
            <returns>Returns the object used for performing memory I/O operations on the target process.</returns>
            <seealso cref="M:RAMvader.CodeInjection.Injector`3.SetTargetProcess(RAMvader.RAMvaderTarget)"/>
        </member>
        <member name="M:RAMvader.CodeInjection.Injector`3.SetCodeCavesSeparationBytes(System.Byte[])">
            <summary>Modifies the sequence of bytes used to separate two consecutive code caves.</summary>
            <param name="byteSeq">The new sequence of bytes to use as a separator. This can be an empty array, but should not be null.</param>
        </member>
        <member name="M:RAMvader.CodeInjection.Injector`3.GetCodeCavesSeparationBytes">
            <summary>Retrieves the sequence of bytes used to separate two consecutive code caves.</summary>
            <returns>Returns the sequence of bytes used to separate two consecutive code caves in memory.</returns>
        </member>
        <member name="M:RAMvader.CodeInjection.Injector`3.SetVariablesSectionSeparationBytes(System.Byte[])">
            <summary>Modifies the sequence of bytes used to separate the injected code caves section from the injected variables section.</summary>
            <param name="byteSeq">The new sequence of bytes to use as a separator. This can be an empty array, but should not be null.</param>
        </member>
        <member name="M:RAMvader.CodeInjection.Injector`3.GetVariablesSectionSeparationBytes">
            <summary>Retrieves the sequence of bytes used to separate the injected code caves section from the injected variables section.</summary>
            <returns>Returns the sequence of bytes used to separate two consecutive code caves in memory.</returns>
        </member>
        <member name="M:RAMvader.CodeInjection.Injector`3.GetBaseInjectionAddress">
            <summary>Retrieves the address where the <see cref="T:RAMvader.CodeInjection.Injector`3"/> has injected its data on the target process.</summary>
            <returns>
               Returns the base address where the injection has been performed.
               If the <see cref="T:RAMvader.CodeInjection.Injector`3"/> didn't perform the injection yet, the return value is IntPtr.Zero.
            </returns>
            <seealso cref="M:RAMvader.CodeInjection.Injector`3.Inject"/>
            <seealso cref="M:RAMvader.CodeInjection.Injector`3.Inject(RAMvader.MemoryAddress)"/>
        </member>
        <member name="M:RAMvader.CodeInjection.Injector`3.GetCodeCaveOffset(`1)">
            <summary>Retrieves the offset of a given code cave, relative to the base injection address into the target process' memory space.</summary>
            <param name="codeCaveID">The identifier of the code cave.</param>
            <returns>Returns the offset of the given code cave.</returns>
            <exception cref="T:RAMvader.CodeInjection.InjectionArtifactNotFoundException">Thrown when the artifact (injection variable or code cave) could not be found by the method.</exception>
        </member>
        <member name="M:RAMvader.CodeInjection.Injector`3.GetInjectedCodeCaveAddress(`1)">
            <summary>
               Retrieves the address of an injected code cave.
               This method should only be called after a base injection address has been defined for the <see cref="T:RAMvader.CodeInjection.Injector`3"/>
               to Inject code caves and variables.
            </summary>
            <param name="codeCaveID">The identifier of the target code cave.</param>
            <returns>Returns the address of the given code cave, into the target process' memory space.</returns>
            <exception cref="T:RAMvader.CodeInjection.InjectionArtifactNotFoundException">Thrown when the artifact (injection variable or code cave) could not be found by the method.</exception>
        </member>
        <member name="M:RAMvader.CodeInjection.Injector`3.GetInjectedCodeCaveAddressAsBytes(`1)">
            <summary>Retrieves the address of an injected code cave, represented as bytes stored in the target process' memory space.</summary>
            <param name="codeCaveID">The identifier of the target code cave.</param>
            <returns>
               Returns the array of bytes representing the address of the injected code cave, as it is to be stored into the target process'
               memory space.
            </returns>
            <exception cref="T:System.NullReferenceException">
               Thrown when the <see cref="T:RAMvader.RAMvaderTarget"/> associated with the <see cref="T:RAMvader.CodeInjection.Injector`3"/> hasn't been set.
               A <see cref="T:RAMvader.RAMvaderTarget"/> instance can be associated to an <see cref="T:RAMvader.CodeInjection.Injector`3"/> by calling
               the method <see cref="M:RAMvader.CodeInjection.Injector`3.SetTargetProcess(RAMvader.RAMvaderTarget)"/>.
            </exception>
        </member>
        <member name="M:RAMvader.CodeInjection.Injector`3.IsCodeCaveInjected(`1)">
            <summary>
               Verifies if a given code cave has been injected by the <see cref="T:RAMvader.CodeInjection.Injector`3"/> on
               the target process' memory space.
            </summary>
            <param name="caveID">The code cave whose injection needs to be verified.</param>
            <returns>
               If the <see cref="T:RAMvader.CodeInjection.Injector`3"/> hasn't performed the injection procedure yet, or if
               its associated <see cref="P:RAMvader.CodeInjection.Injector`3.TargetProcess"/> object isn't attached, this method returns <code>false</code>.
               Else, this method returns a flag specifying if the code cave has been injected. This method returns false for all code caves without
               a definition, as undefined injection artifacts are never injected.
            </returns>
            <exception cref="T:System.NullReferenceException">Thrown when the <see cref="P:RAMvader.CodeInjection.Injector`3.TargetProcess"/> hasn't been set for this <see cref="T:RAMvader.CodeInjection.Injector`3"/>.</exception>
        </member>
        <member name="M:RAMvader.CodeInjection.Injector`3.GetVariableOffset(`2)">
            <summary>Retrieves the offset of a given variable, relative to the base injection address into the target process' memory space.</summary>
            <param name="varID">The identifier of the variable whose offset is to be retrieved.</param>
            <returns>Returns the offset to given variable.</returns>
            <exception cref="T:RAMvader.CodeInjection.InjectionArtifactNotFoundException">Thrown when the artifact (injection variable or code cave) could not be found by the method.</exception>
        </member>
        <member name="M:RAMvader.CodeInjection.Injector`3.GetInjectedVariableAddress(`2)">
            <summary>
               Retrieves the address of an injected variable.
               This method should only be called after a base injection address has been defined for
               the <see cref="T:RAMvader.CodeInjection.Injector`3"/> to Inject code caves and variables.
            </summary>
            <param name="varID">The identifier of the target variable.</param>
            <returns>Returns the address of the given variable, into the target process' memory space.</returns>
            <exception cref="T:RAMvader.CodeInjection.InjectionArtifactNotFoundException">Thrown when the artifact (injection variable or code cave) could not be found by the method.</exception>
        </member>
        <member name="M:RAMvader.CodeInjection.Injector`3.GetInjectedVariableAddressAsBytes(`2)">
            <summary>Retrieves the address of an injected variable, represented as bytes stored in the target process' memory space.</summary>
            <param name="varID">The identifier of the target variable.</param>
            <returns>
               Returns the array of bytes representing the address of the injected variable, as it is to be stored into the target process'
               memory space.
            </returns>
            <exception cref="T:System.NullReferenceException">
               Thrown when the <see cref="T:RAMvader.RAMvaderTarget"/> associated with the <see cref="T:RAMvader.CodeInjection.Injector`3"/> hasn't been set.
               A <see cref="T:RAMvader.RAMvaderTarget"/> instance can be associated to an <see cref="T:RAMvader.CodeInjection.Injector`3"/> by calling
               the method <see cref="M:RAMvader.CodeInjection.Injector`3.SetTargetProcess(RAMvader.RAMvaderTarget)"/>.
            </exception>
        </member>
        <member name="M:RAMvader.CodeInjection.Injector`3.IsVariableInjected(`2)">
            <summary>
               Verifies if a given variable has been injected by the <see cref="T:RAMvader.CodeInjection.Injector`3"/> on
               the target process' memory space.
            </summary>
            <param name="varID">The variable whose injection needs to be verified.</param>
            <returns>
               If the <see cref="T:RAMvader.CodeInjection.Injector`3"/> hasn't performed the injection procedure yet, or if
               its associated <see cref="P:RAMvader.CodeInjection.Injector`3.TargetProcess"/> object isn't attached, this method returns <code>false</code>.
               Else, this method returns a flag specifying if the variable has been injected. This method returns false for all variables without
               a definition, as undefined injection artifacts are never injected.
            </returns>
            <exception cref="T:System.NullReferenceException">Thrown when the <see cref="P:RAMvader.CodeInjection.Injector`3.TargetProcess"/> hasn't been set for this <see cref="T:RAMvader.CodeInjection.Injector`3"/>.</exception>
        </member>
        <member name="M:RAMvader.CodeInjection.Injector`3.GetVariableSize(`2)">
            <summary>Retrieves the size of a given injection variable.</summary>
            <param name="varID">The identifier of the variable whose size is to be retrieved.</param>
            <returns>
               Returns the size of the given injection variable, given in bytes.
               If the variable has no definition set for it, the returned size is ZERO.
            </returns>
            <exception cref="T:System.NullReferenceException">
               Thrown when the <see cref="T:RAMvader.RAMvaderTarget"/> associated with the <see cref="T:RAMvader.CodeInjection.Injector`3"/> hasn't been set.
               A <see cref="T:RAMvader.RAMvaderTarget"/> instance can be associated to an <see cref="T:RAMvader.CodeInjection.Injector`3"/> by calling
               the method <see cref="M:RAMvader.CodeInjection.Injector`3.SetTargetProcess(RAMvader.RAMvaderTarget)"/>.
            </exception>
        </member>
        <member name="M:RAMvader.CodeInjection.Injector`3.CalculateRequiredBytesCount">
            <summary>
               Calculates the total number of required bytes to inject the code caves and variables into the target process' memory space.
               This calculation takes in consideration the separation bytes between two consecutive code caves, the separation between the
               code caves section and the variables section and the size of each one of the injection variables.
            </summary>
            <returns>Returns the number of bytes required to Inject into the target process' memory.</returns>
        </member>
        <member name="M:RAMvader.CodeInjection.Injector`3.AddMemoryAlteration(`0,RAMvader.CodeInjection.MemoryAlterationBase)">
            <summary>
               Adds a memory alteration to the set of alterations related to a given identifier.
               Memory alteration sets are kept in as list, and this method adds a memory alteration to the end of this list.
               The elements of a set of memory alterations are enabled/disabled in the order they get added to the list.
               You can then call <see cref="M:RAMvader.CodeInjection.Injector`3.SetMemoryAlterationsActive(`0,System.Boolean)"/> to enable or disable the whole set of alterations related to an identifier.
            </summary>
            <param name="memoryAlterationSetID">The identifier that identifies the set of alterations that can be enabled/disabled all at once.</param>
            <param name="memoryAlteration">An object representing the memory alteration that should be added to the given set.</param>
        </member>
        <member name="M:RAMvader.CodeInjection.Injector`3.RemoveMemoryAlteration(`0,RAMvader.CodeInjection.MemoryAlterationBase)">
            <summary>
               Removes a memory alteration from the set of alterations related to a given identifier.
               Memory alteration sets are kept in as list, and this method removes a memory alteration from this list.
               The elements of a set of memory alterations are enabled/disabled in the order they get added to the list.
               You can then call <see cref="M:RAMvader.CodeInjection.Injector`3.SetMemoryAlterationsActive(`0,System.Boolean)"/> to enable or disable the whole set of alterations related to an identifier.
            </summary>
            <param name="memoryAlterationSetID">The identifier that identifies the set of alterations that can be enabled/disabled all at once.</param>
            <param name="memoryAlteration">The memory alteration to be removed from the given set.</param>
            <returns>Returns a flag specifying if the alteration has been removed from the set.</returns>
        </member>
        <member name="M:RAMvader.CodeInjection.Injector`3.GetMemoryAlterations(`0)">
            <summary>Returns an enumerable object containing all memory alterations registered for a given memory alteration set.</summary>
            <param name="memoryAlterationSetID">The identifier that identifies the set of alterations that can be enabled/disabled all at once.</param>
            <returns>Returns an enumerable list containing all the memory alterations in the given set.</returns>
        </member>
        <member name="M:RAMvader.CodeInjection.Injector`3.SetMemoryAlterationsActive(`0,System.Boolean)">
            <summary>Activates or deactivates all the memory alterations registered for a given memory alterations set.</summary>
            <param name="memoryAlterationSetID">The identifier that identifies the set of alterations that can be enabled/disabled all at once.</param>
            <param name="bActivate">A flag specifying if the alterations should be activated or deactivated.</param>
            <returns>
               Returns a flag specifying if all alterations have been activated.
               If any of the memory alterations in a set fail to be activated/deactivated, the returned value is false.
            </returns>
        </member>
        <member name="M:RAMvader.CodeInjection.Injector`3.SetAllMemoryAlterationsActive(System.Boolean)">
            <summary>Activates or deactivates all the memory alterations registered with the <see cref="T:RAMvader.CodeInjection.Injector`3"/>.</summary>
            <param name="bActivate">A flag specifying if the alterations should be activated or deactivated.</param>
            <returns>
               Returns a flag specifying if all alterations have been activated.
               If any of the memory alterations in a set fail to be activated/deactivated, the returned value is false.
            </returns>
        </member>
        <member name="M:RAMvader.CodeInjection.Injector`3.NewCodeCave">
            <summary>
               Instantiates a <see cref="T:RAMvader.CodeInjection.CodeCaveBuilder`3"/> to allow
               for the creation of a new code cave that can be used with this <see cref="T:RAMvader.CodeInjection.Injector`3"/>.
            </summary>
            <returns>Returns a builder that can be used to create a new code cave for this <see cref="T:RAMvader.CodeInjection.Injector`3"/>.</returns>
        </member>
        <member name="M:RAMvader.CodeInjection.Injector`3.Inject">
            <summary>
               Allocates memory into the target process' memory space and injects the code caves and
               variables into that allocated memory.
            </summary>
            <exception cref="T:System.NullReferenceException">
               Thrown when the <see cref="T:RAMvader.RAMvaderTarget"/> associated with the <see cref="T:RAMvader.CodeInjection.Injector`3"/> hasn't been set.
               A <see cref="T:RAMvader.RAMvaderTarget"/> instance can be associated to an <see cref="T:RAMvader.CodeInjection.Injector`3"/> by calling
               the method <see cref="M:RAMvader.CodeInjection.Injector`3.SetTargetProcess(RAMvader.RAMvaderTarget)"/>.
            </exception>
            <exception cref="T:RAMvader.InstanceNotAttachedException">
               Thrown when the <see cref="T:RAMvader.RAMvaderTarget"/> instance has not been attached to a target
               process before the method is called.
            </exception>
            <exception cref="T:RAMvader.CodeInjection.VirtualMemoryAllocationException">
               Thrown when the method cannot allocate virtual memory in the target process' memory space, to inject the data in the target process.
               Some softwares might implement security schemes that prevent you from allocating virtual memory on them, which in turn might require you
               to use manual injection of data (see <see cref="M:RAMvader.CodeInjection.Injector`3.Inject(RAMvader.MemoryAddress)"/>).
            </exception>
            <seealso cref="M:RAMvader.CodeInjection.Injector`3.GetBaseInjectionAddress"/>
        </member>
        <member name="M:RAMvader.CodeInjection.Injector`3.Inject(RAMvader.MemoryAddress)">
            <summary>
               <para>
                  Injects the code caves and variables into the target process' memory space.
                  This overloaded version of the <see cref="M:RAMvader.CodeInjection.Injector`3.Inject"/> method can be used to Inject the code caves into a specific point of the
                  target process' memory space. Notice, though, that for the code caves to work correctly, they need to be injected
                  into a memory region with appropriate permissions. Those are usually READ+WRITE+EXECUTE permissions (READ+WRITE
                  for injected variables and EXECUTE for allowing the target process to execute the code caves). If you need to
                  calculate the total number of bytes required by the <see cref="T:RAMvader.CodeInjection.Injector`3"/> to inject
                  the code caves and variables, see <see cref="M:RAMvader.CodeInjection.Injector`3.CalculateRequiredBytesCount"/>.
               </para>
               <para>
                  Notice that you should not use the <see cref="T:RAMvader.InjectedCodeCaveMemoryAddress`3"/> and <see cref="T:RAMvader.InjectedVariableMemoryAddress`3"/> classes
                  to specify the injection point for this method, because for these classes to solve the right base address, they would require a
                  previous injection to have happened already.
               </para>
            </summary>
            <param name="baseInjectionAddress">
               The address - into the target process' memory space - where the <see cref="T:RAMvader.CodeInjection.Injector`3"/>
               will Inject the code caves and variables.
               A value of "IntPtr.Zero" will cause the method to exit without any effect on the target process' memory space.
            </param>
            <exception cref="T:System.NullReferenceException">
               Thrown when the <see cref="T:RAMvader.RAMvaderTarget"/> associated with the <see cref="T:RAMvader.CodeInjection.Injector`3"/> hasn't been set.
               A <see cref="T:RAMvader.RAMvaderTarget"/> instance can be associated to an <see cref="T:RAMvader.CodeInjection.Injector`3"/> by calling
               the method <see cref="M:RAMvader.CodeInjection.Injector`3.SetTargetProcess(RAMvader.RAMvaderTarget)"/>.
            </exception>
            <exception cref="T:RAMvader.InstanceNotAttachedException">
               Thrown when the <see cref="T:RAMvader.RAMvaderTarget"/> instance has not been attached to a target
               process before the method is called.
            </exception>
            <exception cref="T:RAMvader.RequiredWriteException">
               Thrown when the <see cref="T:RAMvader.CodeInjection.Injector`3"/> fails to write the injection
               data in the target process' memory space.
            </exception>
            <seealso cref="M:RAMvader.CodeInjection.Injector`3.GetBaseInjectionAddress"/>
        </member>
        <member name="M:RAMvader.CodeInjection.Injector`3.GetCurrentInjectionOffset">
            <summary>
               Called during the injection procedure to retrieve the number of bytes already generated by
               the <see cref="T:RAMvader.CodeInjection.Injector`3"/> instance.
               This method is called by lower APIs which need to use the current injection position, mainly to generate
               instructions such as NEAR/FAR JUMPs and CALLs.
            </summary>
            <returns>
               <para>
                  Returns the number of bytes that have already been generated by
                  the <see cref="T:RAMvader.CodeInjection.Injector`3"/> during an injection
                  procedure.
               </para>
               <para>
                  If the injection procedure hasn't started yet, or the <see cref="T:RAMvader.CodeInjection.Injector`3"/>
                  finds itself in "not injected" state, the return value is zero.
               </para>
               <para>
                  If this method is called after a successful injection procedure, the return value is the total number of
                  injected bytes (which is effectivelly the same result of calling <see cref="M:RAMvader.CodeInjection.Injector`3.CalculateRequiredBytesCount"/>).
               </para>
               <para>
                  If this method is called during the injection procedure (which is usually done when
                  processing <see cref="T:RAMvader.CodeInjection.CodeCaveArtifact`3"/> objects that compose
                  the code caves to be injected), the return value is the total number of bytes that have been injected so far by
                  the <see cref="T:RAMvader.CodeInjection.Injector`3"/>.
               </para>
            </returns>
            <seealso cref="M:RAMvader.CodeInjection.Injector`3.GetCurrentInjectionAddress"/>
        </member>
        <member name="M:RAMvader.CodeInjection.Injector`3.GetCurrentInjectionAddress">
            <summary>
               <para>
                  Called during the injection procedure to retrieve the address right after the last byte generated by
                  the <see cref="T:RAMvader.CodeInjection.Injector`3"/> instance.
                  This method is called by lower APIs which need to use the current injection position, mainly to generate
                  instructions such as NEAR/FAR JUMPs and CALLs.
               </para>
               <para>
                  The return value of this method is effectivelly the sum of <see cref="P:RAMvader.CodeInjection.Injector`3.BaseInjectionAddress"/> with the
                  return value of the <see cref="M:RAMvader.CodeInjection.Injector`3.GetCurrentInjectionOffset"/> method.
               </para>
            </summary>
            <returns>
                  The return value of this method is effectivelly the sum of <see cref="P:RAMvader.CodeInjection.Injector`3.BaseInjectionAddress"/> with the
                  return value of the <see cref="M:RAMvader.CodeInjection.Injector`3.GetCurrentInjectionOffset"/> method.
            </returns>
            <seealso cref="M:RAMvader.CodeInjection.Injector`3.GetCurrentInjectionAddress"/>
        </member>
        <member name="M:RAMvader.CodeInjection.Injector`3.ResetAllocatedMemoryData">
            <summary>
               Resets the internal data of the <see cref="T:RAMvader.CodeInjection.Injector`3"/> regarding the memory region where it has injected its data.
               This method should be called whenever the target process is terminated or whenever the <see cref="T:RAMvader.CodeInjection.Injector`3"/> object
               needs to deallocate the memory it has allocated on the target process.
            </summary>
        </member>
        <member name="M:RAMvader.CodeInjection.Injector`3.WriteX86CallInstruction(RAMvader.MemoryAddress,RAMvader.MemoryAddress,System.Int32)">
            <summary>
               Writes a x86 CALL instruction at a specific point of the target process' memory space to enable the process' execution flow
               to be detoured to a specific address.
            </summary>
            <param name="detourPoint">The address of the target process' memory space where the CALL instruction will be written.</param>
            <param name="targetAddress">The address to where the target process' execution should be diverted.</param>
            <param name="instructionSize">
               The size of the instruction that is going to be replaced by the CALL instruction.
               This is used to fill the remaining bytes of the instruction with NOP opcodes, so that when the execution flows back from
               the CALL instruction, nothing unexpected happens.
            </param>
            <returns>Returns a flag indicating the success of the operation.</returns>
            <exception cref="T:System.NullReferenceException">
               Thrown when the <see cref="T:RAMvader.RAMvaderTarget"/> associated with the <see cref="T:RAMvader.CodeInjection.Injector`3"/> hasn't been set.
               A <see cref="T:RAMvader.RAMvaderTarget"/> instance can be associated to an <see cref="T:RAMvader.CodeInjection.Injector`3"/> by calling
               the method <see cref="M:RAMvader.CodeInjection.Injector`3.SetTargetProcess(RAMvader.RAMvaderTarget)"/>.
            </exception>
            <exception cref="T:RAMvader.InstanceNotAttachedException">
               Thrown when the <see cref="T:RAMvader.RAMvaderTarget"/> instance has not been attached to a target
               process before the method is called.
            </exception>
        </member>
        <member name="M:RAMvader.CodeInjection.Injector`3.WriteX86NearJumpInstruction(RAMvader.EJumpInstructionType,RAMvader.MemoryAddress,RAMvader.MemoryAddress,System.Int32)">
            <summary>
               Writes a x86 NEAR JUMP instruction at a specific point of the target process' memory space to enable the process'
               execution flow to be detoured to a specific address.
            </summary>
            <param name="jumpInstructionType">The specific type of jump instruction to be written.</param>
            <param name="detourPoint">The address of the target process' memory space where the JUMP instruction will be written.</param>
            <param name="targetAddress">The address to where the target process' execution should be diverted.</param>
            <param name="instructionSize">
               The size of the instruction that is going to be replaced by the JUMP instruction.
               This is used to fill the remaining bytes of the instruction with NOP opcodes, to keep the other instructions' balance
               unaffected by the new jump instruction.
            </param>
            <returns>Returns a flag indicating the success of the operation.</returns>
            <exception cref="T:System.NullReferenceException">
               Thrown when the <see cref="T:RAMvader.RAMvaderTarget"/> associated with the <see cref="T:RAMvader.CodeInjection.Injector`3"/> hasn't been set.
               A <see cref="T:RAMvader.RAMvaderTarget"/> instance can be associated to an <see cref="T:RAMvader.CodeInjection.Injector`3"/> by calling
               the method <see cref="M:RAMvader.CodeInjection.Injector`3.SetTargetProcess(RAMvader.RAMvaderTarget)"/>.
            </exception>
            <exception cref="T:RAMvader.InstanceNotAttachedException">
               Thrown when the <see cref="T:RAMvader.RAMvaderTarget"/> instance has not been attached to a target
               process before the method is called.
            </exception>
        </member>
        <member name="M:RAMvader.CodeInjection.Injector`3.WriteX86FarJumpInstruction(RAMvader.EJumpInstructionType,RAMvader.MemoryAddress,RAMvader.MemoryAddress,System.Int32)">
            <summary>
               Writes a x86 FAR JUMP instruction at a specific point of the target process' memory space to enable the process'
               execution flow to be detoured to a specific address.
            </summary>
            <param name="jumpInstructionType">The specific type of jump instruction to be written.</param>
            <param name="detourPoint">The address of the target process' memory space where the JUMP instruction will be written.</param>
            <param name="targetAddress">The address to where the target process' execution should be diverted.</param>
            <param name="instructionSize">
               The size of the instruction that is going to be replaced by the JUMP instruction.
               This is used to fill the remaining bytes of the instruction with NOP opcodes, to keep the other instructions' balance
               unaffected by the new jump instruction.
            </param>
            <returns>Returns a flag indicating the success of the operation.</returns>
            <exception cref="T:System.NullReferenceException">
               Thrown when the <see cref="T:RAMvader.RAMvaderTarget"/> associated with the <see cref="T:RAMvader.CodeInjection.Injector`3"/> hasn't been set.
               A <see cref="T:RAMvader.RAMvaderTarget"/> instance can be associated to an <see cref="T:RAMvader.CodeInjection.Injector`3"/> by calling
               the method <see cref="M:RAMvader.CodeInjection.Injector`3.SetTargetProcess(RAMvader.RAMvaderTarget)"/>.
            </exception>
            <exception cref="T:RAMvader.InstanceNotAttachedException">
               Thrown when the <see cref="T:RAMvader.RAMvaderTarget"/> instance has not been attached to a target
               process before the method is called.
            </exception>
        </member>
        <member name="M:RAMvader.CodeInjection.Injector`3.WriteVariableValue(`2,System.Object)">
            <summary>
               Updates the value of a given variable into the target process' memory.
               This method is safe, as it checks the given variable's metadata against the given value's type to see if it matches
               the variable's type before updating the variable's value.
            </summary>
            <param name="variableID">The identifier of the injected variable whose value is to be updated.</param>
            <param name="newValue">The new value for the variable.</param>
            <returns>Returns the result of the write operation performed by a call to <see cref="M:RAMvader.RAMvaderTarget.WriteToTarget(RAMvader.MemoryAddress,System.Object)"/>.</returns>
            <exception cref="T:System.NullReferenceException">
               Thrown when the <see cref="T:RAMvader.RAMvaderTarget"/> associated with the <see cref="T:RAMvader.CodeInjection.Injector`3"/> hasn't been set.
               A <see cref="T:RAMvader.RAMvaderTarget"/> instance can be associated to an <see cref="T:RAMvader.CodeInjection.Injector`3"/> by calling
               the method <see cref="M:RAMvader.CodeInjection.Injector`3.SetTargetProcess(RAMvader.RAMvaderTarget)"/>.
            </exception>
            <exception cref="T:RAMvader.InstanceNotAttachedException">
               Thrown when the <see cref="T:RAMvader.RAMvaderTarget"/> instance has not been attached to a target
               process before the method is called.
            </exception>
            <exception cref="T:RAMvader.CodeInjection.UnmatchedDataTypeException">Thrown when "newValue" does not match the injection variable's type.</exception>
            <exception cref="T:RAMvader.CodeInjection.InjectionArtifactNotFoundException">
               Thrown when the variable has not been injected in the target process' memory space.
               This happens when the variable has no definition (<see cref="T:RAMvader.CodeInjection.VariableDefinition"/>) registered for it with
               the <see cref="T:RAMvader.CodeInjection.Injector`3"/>.
            </exception>
        </member>
        <member name="M:RAMvader.CodeInjection.Injector`3.ReadVariableValue``1(`2,``0@)">
            <summary>
               Reads the current value of a given variable from the target process' memory.
               This method is safe, as it checks the given variable's metadata against the given output variable's type to
               see if it matches the injected variable's type before reading the output value.
            </summary>
            <typeparam name="T">The type of the variable to be read, which must match the type of the injected variable.</typeparam>
            <param name="variableID">The identifier of the variable whose value is to be read from the target process' memory space.</param>
            <param name="outDestiny">
               The result of the reading will be stored in this variable.
               The referenced variable's data must be of the same type as declared for the variable defined in parameter <code>variableID</code>.
            </param>
            <returns>Returns the result of the read operation performed by a call to <see cref="M:RAMvader.RAMvaderTarget.ReadFromTarget``1(RAMvader.MemoryAddress,``0@)"/>.</returns>
            <exception cref="T:System.NullReferenceException">
               Thrown when the <see cref="T:RAMvader.RAMvaderTarget"/> associated with the <see cref="T:RAMvader.CodeInjection.Injector`3"/> hasn't been set.
               A <see cref="T:RAMvader.RAMvaderTarget"/> instance can be associated to an <see cref="T:RAMvader.CodeInjection.Injector`3"/> by calling
               the method <see cref="M:RAMvader.CodeInjection.Injector`3.SetTargetProcess(RAMvader.RAMvaderTarget)"/>.
            </exception>
            <exception cref="T:RAMvader.InstanceNotAttachedException">
               Thrown when the <see cref="T:RAMvader.RAMvaderTarget"/> instance has not been attached to a target
               process before the method is called.
            </exception>
            <exception cref="T:RAMvader.CodeInjection.InjectionArtifactNotFoundException">
               Thrown when the variable has not been injected in the target process' memory space.
               This happens when the variable has no definition (<see cref="T:RAMvader.CodeInjection.VariableDefinition"/>) registered for it with
               the <see cref="T:RAMvader.CodeInjection.Injector`3"/>.
            </exception>
        </member>
        <member name="M:RAMvader.CodeInjection.Injector`3.SetCodeCaveDefinition(`1,RAMvader.CodeInjection.CodeCaveDefinition{`0,`1,`2})">
            <summary>
               <para>Updates the definition of a given code cave.</para>
               <para>
                  Currently, the definitions of code caves and injection variables can only
                  be updated when the <see cref="T:RAMvader.CodeInjection.Injector`3"/> is
                  in the "not injected" state.
               </para>
            </summary>
            <param name="caveId">The identifier of the code cave whose definition is to be updated.</param>
            <param name="definition">An object representing the new definition of the given code cave.</param>
            <exception cref="T:RAMvader.CodeInjection.InstanceAlreadyInjectedException">
               Thrown when the <see cref="T:RAMvader.CodeInjection.Injector`3"/>'s
               instance is already in "injected" state (this method must be called before that
               state is entered).
            </exception>
        </member>
        <member name="M:RAMvader.CodeInjection.Injector`3.SetVariableDefinition(`2,RAMvader.CodeInjection.VariableDefinition)">
            <summary>
               <para>Updates the definition of a given injection variable.</para>
               <para>
                  Currently, the definitions of code caves and injection variables can only
                  be updated when the <see cref="T:RAMvader.CodeInjection.Injector`3"/> is
                  in the "not injected" state.
               </para>
            </summary>
            <param name="varId">The identifier of the injection variable whose definition is to be updated.</param>
            <param name="definition">An object representing the new definition of the given injection variable.</param>
            <exception cref="T:RAMvader.CodeInjection.InstanceAlreadyInjectedException">
               Thrown when the <see cref="T:RAMvader.CodeInjection.Injector`3"/>'s
               instance is already in "injected" state (this method must be called before that
               state is entered).
            </exception>
            <exception cref="T:RAMvader.UnsupportedDataTypeException">
               Throw when the type of the 
            </exception>
        </member>
        <member name="M:RAMvader.CodeInjection.Injector`3.GetCodeCaveDefinition(`1)">
            <summary>
               Retrieves the definition of the given code cave, that has been registered with the
               <see cref="T:RAMvader.CodeInjection.Injector`3"/>, if any.
            </summary>
            <param name="caveId">The identifier of the code cave whose definition is to be retrieved.</param>
            <returns>
               <para>
                  In case of success, returns the <see cref="T:RAMvader.CodeInjection.CodeCaveDefinition`3"/> object
                  representing the definition that has been registered for the given code cave.
               </para>
               <para>In case of failure, returns <code>null</code>.</para>
            </returns>
        </member>
        <member name="M:RAMvader.CodeInjection.Injector`3.GetVariableDefinition(`2)">
            <summary>
               Retrieves the definition of the given injection variable, that has been registered with the
               <see cref="T:RAMvader.CodeInjection.Injector`3"/>, if any.
            </summary>
            <param name="varId">The identifier of the injection variable whose definition is to be retrieved.</param>
            <returns>
               <para>
                  In case of success, returns the <see cref="T:RAMvader.CodeInjection.VariableDefinition"/> object
                  representing the definition that has been registered for the given injection variable.
               </para>
               <para>In case of failure, returns <code>null</code>.</para>
            </returns>
        </member>
        <member name="M:RAMvader.CodeInjection.Injector`3.ClearCodeCaveDefinition(`1)">
            <summary>
               <para>
                  Clears the definition of a specific code cave, effectively making
                  it "undefined" for
                  the <see cref="T:RAMvader.CodeInjection.Injector`3"/>.
               </para>
               <para>
                  Calling this will prevent the code cave from being injected in the
                  target process' memory space - as its definition will be voided - until it gets
                  redefined/updated.
               </para>
               <para>
                  Currently, the definitions of code caves and injection variables can only
                  be updated when the <see cref="T:RAMvader.CodeInjection.Injector`3"/> is
                  in the "not injected" state.
               </para>
            </summary>
            <param name="caveId">The code cave whose definition will be cleared.</param>
            <returns>Returns a flag specifying if the definition has been found and removed.</returns>
        </member>
        <member name="M:RAMvader.CodeInjection.Injector`3.ClearVariableDefinition(`2)">
            <summary>
               <para>
                  Clears the definition of a specific injection variable, effectively making
                  it "undefined" for
                  the <see cref="T:RAMvader.CodeInjection.Injector`3"/>.
               </para>
               <para>
                  Calling this will prevent the injection variable from being injected in the
                  target process' memory space - as its definition will be voided - until it gets
                  redefined/updated.
               </para>
               <para>
                  Currently, the definitions of code caves and injection variables can only
                  be updated when the <see cref="T:RAMvader.CodeInjection.Injector`3"/> is
                  in the "not injected" state.
               </para>
            </summary>
            <param name="varId">The injection variable whose definition will be cleared.</param>
            <returns>Returns a flag specifying if the definition has been found and removed.</returns>
        </member>
        <member name="M:RAMvader.CodeInjection.Injector`3.ClearAllCodeCaveDefinitions">
            <summary>
               <para>
                  Clears the definition of all code caves, effectively making
                  all of them "undefined" for
                  the <see cref="T:RAMvader.CodeInjection.Injector`3"/>.
               </para>
               <para>
                  Calling this will prevent the code caves from being injected in the
                  target process' memory space - as their definition will be voided - until they get
                  redefined/updated.
               </para>
               <para>
                  Currently, the definitions of code caves and injection variables can only
                  be updated when the <see cref="T:RAMvader.CodeInjection.Injector`3"/> is
                  in the "not injected" state.
               </para>
            </summary>
        </member>
        <member name="M:RAMvader.CodeInjection.Injector`3.ClearAllVariableDefinitions">
            <summary>
               <para>
                  Clears the definition of all injection varibles, effectively making
                  all of them "undefined" for
                  the <see cref="T:RAMvader.CodeInjection.Injector`3"/>.
               </para>
               <para>
                  Calling this will prevent the injection variables from being injected in the
                  target process' memory space - as their definition will be voided - until they get
                  redefined/updated.
               </para>
               <para>
                  Currently, the definitions of code caves and injection variables can only
                  be updated when the <see cref="T:RAMvader.CodeInjection.Injector`3"/> is
                  in the "not injected" state.
               </para>
            </summary>
        </member>
        <member name="F:RAMvader.CodeInjection.Injector`3.DEFAULT_INDEXER_PROPERTY_NAME">
            <summary>
               The default name of an indexer property, which is used to raise the "property changed"
               event (provided by standard WPF INotifyPropertyChanged implementation) when a indexer property
               has its value updated.
            </summary>
        </member>
        <member name="T:RAMvader.CodeInjection.Injector`3.NestedPropertyIndexerCodeCaveOffset">
            <summary>Provides an indexer used to access code cave offsets, through the property <see cref="P:RAMvader.CodeInjection.Injector`3.CodeCaveOffset"/>.</summary>
        </member>
        <member name="F:RAMvader.CodeInjection.Injector`3.NestedPropertyIndexerCodeCaveOffset.m_injector">
            <summary>Reference to the <see cref="T:RAMvader.CodeInjection.Injector`3"/> which owns this object.</summary>
        </member>
        <member name="M:RAMvader.CodeInjection.Injector`3.NestedPropertyIndexerCodeCaveOffset.#ctor(RAMvader.CodeInjection.Injector{`0,`1,`2})">
            <summary>
               Constructor.
               The internal scope-modifier ensures this class will not be instanced outside of the <see cref="T:RAMvader.CodeInjection.Injector`3"/> class.
            </summary>
            <param name="injector">A reference to the <see cref="T:RAMvader.CodeInjection.Injector`3"/> object used to retrieve data for the indexer property.</param>
        </member>
        <member name="P:RAMvader.CodeInjection.Injector`3.NestedPropertyIndexerCodeCaveOffset.Item(`1)">
            <summary>Indexer used to retrieve the offset of a code cave, through a call to <see cref="M:RAMvader.CodeInjection.Injector`3.GetCodeCaveOffset(`1)"/>.</summary>
            <param name="codeCaveID">The identifier of the code cave whose offset is to be retrieved.</param>
            <returns>Returns the offset of the given code cave.</returns>
        </member>
        <member name="T:RAMvader.CodeInjection.Injector`3.NestedPropertyIndexerInjectedCodeCaveAddress">
            <summary>
               Provides an indexer used to access the address where a code cave has been injected,
               through <see cref="P:RAMvader.CodeInjection.Injector`3.InjectedCodeCaveAddress"/>.
            </summary>
        </member>
        <member name="F:RAMvader.CodeInjection.Injector`3.NestedPropertyIndexerInjectedCodeCaveAddress.m_injector">
            <summary>Reference to the <see cref="T:RAMvader.CodeInjection.Injector`3"/> which owns this object.</summary>
        </member>
        <member name="M:RAMvader.CodeInjection.Injector`3.NestedPropertyIndexerInjectedCodeCaveAddress.#ctor(RAMvader.CodeInjection.Injector{`0,`1,`2})">
            <summary>
               Constructor.
               The internal scope-modifier ensures this class will not be instanced outside of the <see cref="T:RAMvader.CodeInjection.Injector`3"/> class.
            </summary>
            <param name="injector">A reference to the <see cref="T:RAMvader.CodeInjection.Injector`3"/> object used to retrieve data for the indexer property.</param>
        </member>
        <member name="P:RAMvader.CodeInjection.Injector`3.NestedPropertyIndexerInjectedCodeCaveAddress.Item(`1)">
            <summary>
               Indexer used to retrieve the address where a code cave has been injected, through a call
               to <see cref="T:RAMvader.CodeInjection.Injector`3"/>.GetInjectedCodeCaveAddress().
            </summary>
            <param name="codeCaveID">The identifier of the code cave whose injected address is to be retrieved.</param>
            <returns>Returns the address where the code cave has been injected.</returns>
        </member>
        <member name="T:RAMvader.CodeInjection.Injector`3.NestedPropertyIndexerVariableOffset">
            <summary>Provides an indexer used to access variable offsets, through the property <see cref="T:RAMvader.CodeInjection.Injector`3"/>.VariableOffset.</summary>
        </member>
        <member name="F:RAMvader.CodeInjection.Injector`3.NestedPropertyIndexerVariableOffset.m_injector">
            <summary>Reference to the <see cref="T:RAMvader.CodeInjection.Injector`3"/> which owns this object.</summary>
        </member>
        <member name="M:RAMvader.CodeInjection.Injector`3.NestedPropertyIndexerVariableOffset.#ctor(RAMvader.CodeInjection.Injector{`0,`1,`2})">
            <summary>
               Constructor.
               The internal scope-modifier ensures this class will not be instanced outside of the <see cref="T:RAMvader.CodeInjection.Injector`3"/> class.
            </summary>
            <param name="injector">A reference to the <see cref="T:RAMvader.CodeInjection.Injector`3"/> object used to retrieve data for the indexer property.</param>
        </member>
        <member name="P:RAMvader.CodeInjection.Injector`3.NestedPropertyIndexerVariableOffset.Item(`2)">
            <summary>Indexer used to retrieve the offset of a variable, through a call to <see cref="T:RAMvader.CodeInjection.Injector`3"/>.GetVariableOffset().</summary>
            <param name="variableID">The identifier of the variable whose offset is to be retrieved.</param>
            <returns>Returns the offset of the given variable.</returns>
        </member>
        <member name="T:RAMvader.CodeInjection.Injector`3.NestedPropertyIndexerInjectedVariableAddress">
            <summary>
               Provides an indexer used to access the address where a variable has been injected,
               through the property <see cref="T:RAMvader.CodeInjection.Injector`3"/>.InjectedVariableAddress.
            </summary>
        </member>
        <member name="F:RAMvader.CodeInjection.Injector`3.NestedPropertyIndexerInjectedVariableAddress.m_injector">
            <summary>Reference to the <see cref="T:RAMvader.CodeInjection.Injector`3"/> which owns this object.</summary>
        </member>
        <member name="M:RAMvader.CodeInjection.Injector`3.NestedPropertyIndexerInjectedVariableAddress.#ctor(RAMvader.CodeInjection.Injector{`0,`1,`2})">
            <summary>
               Constructor.
               The internal scope-modifier ensures this class will not be instanced outside of the <see cref="T:RAMvader.CodeInjection.Injector`3"/> class.
            </summary>
            <param name="injector">A reference to the <see cref="T:RAMvader.CodeInjection.Injector`3"/> object used to retrieve data for the indexer property.</param>
        </member>
        <member name="P:RAMvader.CodeInjection.Injector`3.NestedPropertyIndexerInjectedVariableAddress.Item(`2)">
            <summary>
               Indexer used to retrieve the address where a variable has been injected, through a call
               to <see cref="T:RAMvader.CodeInjection.Injector`3"/>.GetInjectedVariableAddress().
            </summary>
            <param name="variableID">The identifier of the variable whose injected address is to be retrieved.</param>
            <returns>Returns the address where the given variable has been injected.</returns>
        </member>
        <member name="T:RAMvader.CodeInjection.Injector`3.NestedPropertyIndexerVariableSize">
            <summary>
               Provides an indexer used to retrieve the size of a variable,
               through the property <see cref="T:RAMvader.CodeInjection.Injector`3"/>.VariableSize.
            </summary>
        </member>
        <member name="F:RAMvader.CodeInjection.Injector`3.NestedPropertyIndexerVariableSize.m_injector">
            <summary>Reference to the <see cref="T:RAMvader.CodeInjection.Injector`3"/> which owns this object.</summary>
        </member>
        <member name="M:RAMvader.CodeInjection.Injector`3.NestedPropertyIndexerVariableSize.#ctor(RAMvader.CodeInjection.Injector{`0,`1,`2})">
            <summary>
               Constructor.
               The internal scope-modifier ensures this class will not be instanced outside of the <see cref="T:RAMvader.CodeInjection.Injector`3"/> class.
            </summary>
            <param name="injector">A reference to the <see cref="T:RAMvader.CodeInjection.Injector`3"/> object used to retrieve data for the indexer property.</param>
        </member>
        <member name="P:RAMvader.CodeInjection.Injector`3.NestedPropertyIndexerVariableSize.Item(`2)">
            <summary>Indexer used to retrieve the size of a variable, through a call to <see cref="T:RAMvader.CodeInjection.Injector`3"/>.GetVariableSize().</summary>
            <param name="variableID">The identifier of the variable whose size is to be retrieved.</param>
            <returns>Returns the size of the given variable.</returns>
        </member>
        <member name="T:RAMvader.CodeInjection.InjectorException">
            <summary>A generic expection that might be thrown by the <see cref="T:RAMvader.CodeInjection.Injector`3"/> class.</summary>
        </member>
        <member name="M:RAMvader.CodeInjection.InjectorException.#ctor(System.String)">
            <summary>Constructor.</summary>
            <param name="msg">The message used to initialize the Exception.</param>
        </member>
        <member name="T:RAMvader.CodeInjection.LowLevel">
            <summary>This class is used to keep low-level definitions, such as opcodes that can be used to generate x86 code.</summary>
        </member>
        <member name="F:RAMvader.CodeInjection.LowLevel.OPCODE_x86_NOP">
            <summary>The byte value for the x86 NOP instruction.</summary>
        </member>
        <member name="F:RAMvader.CodeInjection.LowLevel.OPCODE_x86_INT3">
            <summary>The byte value for the x86 INT3 instruction.</summary>
        </member>
        <member name="F:RAMvader.CodeInjection.LowLevel.OPCODE_x86_CALL">
            <summary>Represents the byte value for the x86 CALL instruction.</summary>
        </member>
        <member name="F:RAMvader.CodeInjection.LowLevel.OPCODE_x86_NEAR_JMP">
            <summary>Represents the byte value for the x86 NEAR JMP instruction.</summary>
        </member>
        <member name="F:RAMvader.CodeInjection.LowLevel.OPCODE_x86_NEAR_JA">
            <summary>Represents the byte value for the x86 NEAR JA instruction.</summary>
        </member>
        <member name="F:RAMvader.CodeInjection.LowLevel.OPCODE_x86_NEAR_JAE">
            <summary>Represents the byte value for the x86 NEAR JAE instruction.</summary>
        </member>
        <member name="F:RAMvader.CodeInjection.LowLevel.OPCODE_x86_NEAR_JB">
            <summary>Represents the byte value for the x86 NEAR JB instruction.</summary>
        </member>
        <member name="F:RAMvader.CodeInjection.LowLevel.OPCODE_x86_NEAR_JBE">
            <summary>Represents the byte value for the x86 NEAR JBE instruction.</summary>
        </member>
        <member name="F:RAMvader.CodeInjection.LowLevel.OPCODE_x86_NEAR_JG">
            <summary>Represents the byte value for the x86 NEAR JG instruction.</summary>
        </member>
        <member name="F:RAMvader.CodeInjection.LowLevel.OPCODE_x86_NEAR_JGE">
            <summary>Represents the byte value for the x86 NEAR JGE instruction.</summary>
        </member>
        <member name="F:RAMvader.CodeInjection.LowLevel.OPCODE_x86_NEAR_JL">
            <summary>Represents the byte value for the x86 NEAR JL instruction.</summary>
        </member>
        <member name="F:RAMvader.CodeInjection.LowLevel.OPCODE_x86_NEAR_JLE">
            <summary>Represents the byte value for the x86 NEAR JLE instruction.</summary>
        </member>
        <member name="F:RAMvader.CodeInjection.LowLevel.OPCODE_x86_NEAR_JE">
            <summary>Represents the byte value for the x86 NEAR JE instruction.</summary>
        </member>
        <member name="F:RAMvader.CodeInjection.LowLevel.OPCODE_x86_NEAR_JNE">
            <summary>Represents the byte value for the x86 NEAR JNE instruction.</summary>
        </member>
        <member name="F:RAMvader.CodeInjection.LowLevel.OPCODE_x86_FAR_JMP">
            <summary>Represents the byte value for the x86 FAR JMP instruction.</summary>
        </member>
        <member name="F:RAMvader.CodeInjection.LowLevel.OPCODE_x86_FAR_JA">
            <summary>Represents the byte value for the x86 FAR JA instruction.</summary>
        </member>
        <member name="F:RAMvader.CodeInjection.LowLevel.OPCODE_x86_FAR_JAE">
            <summary>Represents the byte value for the x86 FAR JAE instruction.</summary>
        </member>
        <member name="F:RAMvader.CodeInjection.LowLevel.OPCODE_x86_FAR_JB">
            <summary>Represents the byte value for the x86 FAR JB instruction.</summary>
        </member>
        <member name="F:RAMvader.CodeInjection.LowLevel.OPCODE_x86_FAR_JBE">
            <summary>Represents the byte value for the x86 FAR JBE instruction.</summary>
        </member>
        <member name="F:RAMvader.CodeInjection.LowLevel.OPCODE_x86_FAR_JG">
            <summary>Represents the byte value for the x86 FAR JG instruction.</summary>
        </member>
        <member name="F:RAMvader.CodeInjection.LowLevel.OPCODE_x86_FAR_JGE">
            <summary>Represents the byte value for the x86 FAR JGE instruction.</summary>
        </member>
        <member name="F:RAMvader.CodeInjection.LowLevel.OPCODE_x86_FAR_JL">
            <summary>Represents the byte value for the x86 FAR JL instruction.</summary>
        </member>
        <member name="F:RAMvader.CodeInjection.LowLevel.OPCODE_x86_FAR_JLE">
            <summary>Represents the byte value for the x86 FAR JLE instruction.</summary>
        </member>
        <member name="F:RAMvader.CodeInjection.LowLevel.OPCODE_x86_FAR_JE">
            <summary>Represents the byte value for the x86 FAR JE instruction.</summary>
        </member>
        <member name="F:RAMvader.CodeInjection.LowLevel.OPCODE_x86_FAR_JNE">
            <summary>Represents the byte value for the x86 FAR JNE instruction.</summary>
        </member>
        <member name="F:RAMvader.CodeInjection.LowLevel.INSTRUCTION_SIZE_x86_CALL">
            <summary>The size of a x86 CALL instruction, given in bytes.</summary>
        </member>
        <member name="F:RAMvader.CodeInjection.LowLevel.INSTRUCTION_SIZE_x86_NEAR_JUMP">
            <summary>
               The size of a x86 NEAR JUMP instruction, given in bytes.
               Near jumps allow jumps to instructions up to a distance of 0xFF bytes.
            </summary>
        </member>
        <member name="F:RAMvader.CodeInjection.LowLevel.INSTRUCTION_SIZE_x86_FAR_JUMP">
            <summary>The size of a x86 FAR JUMP instruction, given in bytes.</summary>
        </member>
        <member name="T:RAMvader.CodeInjection.MemoryAlterationBase">
            <summary>Base class for all memory alterations that can be performed through the <see cref="T:RAMvader.CodeInjection.Injector`3"/> class.</summary>
        </member>
        <member name="F:RAMvader.CodeInjection.MemoryAlterationBase.m_targetOriginalBytes">
            <summary>Backs the <see cref="P:RAMvader.CodeInjection.MemoryAlterationBase.TargetOriginalBytes"/> property.</summary>
        </member>
        <member name="F:RAMvader.CodeInjection.MemoryAlterationBase.m_targetAddress">
            <summary>Backs the <see cref="P:RAMvader.CodeInjection.MemoryAlterationBase.TargetAddress"/> property.</summary>
        </member>
        <member name="P:RAMvader.CodeInjection.MemoryAlterationBase.TargetOriginalBytes">
            <summary>
               Keeps the bytes that represent the original instruction or value that was in
               memory before the memory alteration got activated.
            </summary>
        </member>
        <member name="P:RAMvader.CodeInjection.MemoryAlterationBase.TargetAddress">
            <summary>The address (in the target process' memory space) where the memory alteration will occur.</summary>
        </member>
        <member name="M:RAMvader.CodeInjection.MemoryAlterationBase.SetEnabled``3(RAMvader.CodeInjection.Injector{``0,``1,``2},System.Boolean)">
            <summary>Called to activate or deactivate a memory alteration into the target process' memory space.</summary>
            <typeparam name="TMemoryAlterationID">The enumeration of Memory Alteration Sets used for the <see cref="T:RAMvader.CodeInjection.Injector`3"/>.</typeparam>
            <typeparam name="TCodeCave">The enumeration of Code Caves used for the <see cref="T:RAMvader.CodeInjection.Injector`3"/>.</typeparam>
            <typeparam name="TVariable">The enumeration of Injection Variables used for the <see cref="T:RAMvader.CodeInjection.Injector`3"/>.</typeparam>
            <param name="injectorRef">A reference to an <see cref="T:RAMvader.CodeInjection.Injector`3"/> object, with which you can perform I/O operations on the target process' memory space and access related data, like values and addresses of variables and code caves.</param>
            <param name="bEnable">A flag specifying if the memory alteration should be enabled or disabled.</param>
            <returns>Returns a flag specifying if the operation was successful or not.</returns>
        </member>
        <member name="M:RAMvader.CodeInjection.MemoryAlterationBase.#ctor(RAMvader.RAMvaderTarget,RAMvader.MemoryAddress,System.Int32)">
            <summary>
               Constructor.
               The constructor will read the bytes of the target process' memory space and keep a "snapshot" of it at the moment the
               constructor is called. When a memory alteration gets disabled, this "snapshot" will be used to restore the original
               bytes of the instruction or value that was in the target process' memory space before it was activated.
            </summary>
            <param name="targetIORef">A reference to the <see cref="T:RAMvader.RAMvaderTarget"/> object that will be used to read the target process' memory space.</param>
            <param name="targetAddress">The address (in the target process' memory space) where the memory alteration will take place.</param>
            <param name="targetSize">The size - given in bytes - of the instruction or value that the memory alteration will affect.</param>
            <exception cref="T:RAMvader.InstanceNotAttachedException">Thrown when the method is called while the given <see cref="T:RAMvader.RAMvaderTarget"/> is not attached to a process.</exception>
            <exception cref="T:RAMvader.RequiredReadException">
               Thrown when the method cannot successfully read the target process' memory space to retrieve the original bytes
               that the Memory Alteration will be replacing, once it is activated.
            </exception>
        </member>
        <member name="T:RAMvader.CodeInjection.MemoryAlterationX86Call">
            <summary>Represents a memory alteration that overwrites instructions of the target process' memory space with x86 CALL instruction.</summary>
        </member>
        <member name="F:RAMvader.CodeInjection.MemoryAlterationX86Call.m_codeCaveID">
            <summary>The identifier of the code cave to which the CALL instruction will make the target process' code flow.</summary>
        </member>
        <member name="M:RAMvader.CodeInjection.MemoryAlterationX86Call.#ctor(RAMvader.RAMvaderTarget,RAMvader.MemoryAddress,System.Enum,System.Int32)">
            <summary>Constructor.</summary>
            <param name="targetIORef">
               A reference to the <see cref="T:RAMvader.RAMvaderTarget"/> object that will be used to read the target process' memory space.
               This <see cref="T:RAMvader.RAMvaderTarget"/> MUST be attached to a process, as it will be used in this constructor method to read the process'
               memory and keep a snapshot of the original bytes at the given 'targetAddress' for restoring their values,
               whenever <see cref="M:RAMvader.CodeInjection.MemoryAlterationX86Call.SetEnabled``3(RAMvader.CodeInjection.Injector{``0,``1,``2},System.Boolean)"/> is called to deactivate a memory alteration.
            </param>
            <param name="targetAddress">The address of the instruction(s) that will be replaced x86 CALL instruction.</param>
            <param name="targetCodeCaveID">The target code cave, to which the code should be diverted.</param>
            <param name="instructionSize">The size of the instruction(s) that will be replaced with NOP instructions.</param>
        </member>
        <member name="M:RAMvader.CodeInjection.MemoryAlterationX86Call.SetEnabled``3(RAMvader.CodeInjection.Injector{``0,``1,``2},System.Boolean)">
            <summary>Called to activate or deactivate a memory alteration into the target process' memory space.</summary>
            <typeparam name="TMemoryAlterationID">The enumeration of Memory Alteration Sets used for the <see cref="T:RAMvader.CodeInjection.Injector`3" />.</typeparam>
            <typeparam name="TCodeCave">The enumeration of Code Caves used for the <see cref="T:RAMvader.CodeInjection.Injector`3" />.</typeparam>
            <typeparam name="TVariable">The enumeration of Injection Variables used for the <see cref="T:RAMvader.CodeInjection.Injector`3" />.</typeparam>
            <param name="injectorRef">
               A reference to an <see cref="T:RAMvader.CodeInjection.Injector`3" /> object, with which you can perform I/O operations
               on the target process' memory space and access related data, like values and addresses of variables and code caves.
            </param>
            <param name="bEnable">A flag specifying if the memory alteration should be enabled or disabled.</param>
            <returns>Returns a flag specifying if the operation was successful or not.</returns>
        </member>
        <member name="T:RAMvader.CodeInjection.MemoryAlterationX86NearJump">
            <summary>
               Represents a memory alteration that overwrites instructions of the target process' memory space with x86 NEAR JUMP instruction.
               ATTENTION: It is NOT recommended that you use NEAR JUMP instructions to jump to code caves that belong to automatically-allocated
               memory (which is the default behaviour of the <see cref="T:RAMvader.CodeInjection.Injector`3"/> class). If you need to jump to a code cave in automatically-allocated memory spaces,
               you should strongly consider using <see cref="T:RAMvader.CodeInjection.MemoryAlterationX86FarJump"/> instead of <see cref="T:RAMvader.CodeInjection.MemoryAlterationX86NearJump"/>.
            </summary>
        </member>
        <member name="F:RAMvader.CodeInjection.MemoryAlterationX86NearJump.m_codeCaveID">
            <summary>The identifier of the code cave to which the JUMP instruction will make the target process' code flow.</summary>
        </member>
        <member name="F:RAMvader.CodeInjection.MemoryAlterationX86NearJump.m_jumpType">
            <summary>The identifier of the type of x86 FAR JUMP instruction to be generated.</summary>
        </member>
        <member name="M:RAMvader.CodeInjection.MemoryAlterationX86NearJump.#ctor(RAMvader.RAMvaderTarget,RAMvader.MemoryAddress,System.Enum,RAMvader.EJumpInstructionType,System.Int32)">
            <summary>Constructor</summary>
            <param name="targetIORef">
               A reference to the <see cref="T:RAMvader.RAMvaderTarget"/> object that will be used to read the target process' memory space.
               This <see cref="T:RAMvader.RAMvaderTarget"/> MUST be attached to a process, as it will be used in this constructor method to read the process'
               memory and keep a snapshot of the original bytes at the given 'targetAddress' for restoring their values,
               whenever <see cref="M:RAMvader.CodeInjection.MemoryAlterationX86NearJump.SetEnabled``3(RAMvader.CodeInjection.Injector{``0,``1,``2},System.Boolean)"/> is called to deactivate a memory alteration.
            </param>
            <param name="targetAddress">The address of the instruction(s) that will be replaced x86 NEAR JUMP instruction.</param>
            <param name="targetCodeCaveID">The target code cave, to which the code should be diverted.</param>
            <param name="jumpInstructionType">The specific type of jump instruction that should be generated.</param>
            <param name="instructionSize">The size of the instruction that is going to be replaced on the target process' memory space.</param>
        </member>
        <member name="M:RAMvader.CodeInjection.MemoryAlterationX86NearJump.SetEnabled``3(RAMvader.CodeInjection.Injector{``0,``1,``2},System.Boolean)">
            <summary>Called to activate or deactivate a memory alteration into the target process' memory space.</summary>
            <typeparam name="TMemoryAlterationID">The enumeration of Memory Alteration Sets used for the <see cref="T:RAMvader.CodeInjection.Injector`3" />.</typeparam>
            <typeparam name="TCodeCave">The enumeration of Code Caves used for the <see cref="T:RAMvader.CodeInjection.Injector`3" />.</typeparam>
            <typeparam name="TVariable">The enumeration of Injection Variables used for the <see cref="T:RAMvader.CodeInjection.Injector`3" />.</typeparam>
            <param name="injectorRef">A reference to an <see cref="T:RAMvader.CodeInjection.Injector`3"/> object, with which you can perform I/O operations on the target process' memory space and access related data, like values and addresses of variables and code caves.</param>
            <param name="bEnable">A flag specifying if the memory alteration should be enabled or disabled.</param>
            <returns>Returns a flag specifying if the operation was successful or not.</returns>
        </member>
        <member name="T:RAMvader.CodeInjection.MemoryAlterationX86FarJump">
            <summary>Represents a memory alteration that overwrites instructions of the target process' memory space with x86 FAR JUMP instruction.</summary>
        </member>
        <member name="F:RAMvader.CodeInjection.MemoryAlterationX86FarJump.m_codeCaveID">
            <summary>The identifier of the code cave to which the JUMP instruction will make the target process' code flow.</summary>
        </member>
        <member name="F:RAMvader.CodeInjection.MemoryAlterationX86FarJump.m_jumpType">
            <summary>The identifier of the type of x86 FAR JUMP instruction to be generated.</summary>
        </member>
        <member name="M:RAMvader.CodeInjection.MemoryAlterationX86FarJump.#ctor(RAMvader.RAMvaderTarget,RAMvader.MemoryAddress,System.Enum,RAMvader.EJumpInstructionType,System.Int32)">
            <summary>Constructor.</summary>
            <param name="targetIORef">
               A reference to the <see cref="T:RAMvader.RAMvaderTarget"/> object that will be used to read the target process' memory space.
               This <see cref="T:RAMvader.RAMvaderTarget"/> MUST be attached to a process, as it will be used in this constructor method to read the process'
               memory and keep a snapshot of the original bytes at the given 'targetAddress' for restoring their values,
               whenever <see cref="M:RAMvader.CodeInjection.MemoryAlterationX86FarJump.SetEnabled``3(RAMvader.CodeInjection.Injector{``0,``1,``2},System.Boolean)"/> is called to deactivate a memory alteration.
            </param>
            <param name="targetAddress">The address of the instruction(s) that will be replaced x86 NEAR JUMP instruction.</param>
            <param name="targetCodeCaveID">The target code cave, to which the code should be diverted.</param>
            <param name="jumpInstructionType">The specific type of jump instruction that should be generated.</param>
            <param name="instructionSize">The size of the instruction(s) that will be replaced with NOP instructions.</param>
        </member>
        <member name="M:RAMvader.CodeInjection.MemoryAlterationX86FarJump.SetEnabled``3(RAMvader.CodeInjection.Injector{``0,``1,``2},System.Boolean)">
            <summary>Called to activate or deactivate a memory alteration into the target process' memory space.</summary>
            <typeparam name="TMemoryAlterationID">The enumeration of Memory Alteration Sets used for the <see cref="T:RAMvader.CodeInjection.Injector`3" />.</typeparam>
            <typeparam name="TCodeCave">The enumeration of Code Caves used for the <see cref="T:RAMvader.CodeInjection.Injector`3" />.</typeparam>
            <typeparam name="TVariable">The enumeration of Injection Variables used for the <see cref="T:RAMvader.CodeInjection.Injector`3" />.</typeparam>
            <param name="injectorRef">A reference to an <see cref="T:RAMvader.CodeInjection.Injector`3"/> object, with which you can perform I/O operations on the target process' memory space and access related data, like values and addresses of variables and code caves.</param>
            <param name="bEnable">A flag specifying if the memory alteration should be enabled or disabled.</param>
            <returns>Returns a flag specifying if the operation was successful or not.</returns>
        </member>
        <member name="T:RAMvader.CodeInjection.MemoryAlterationNOP">
            <summary>Represents a memory alteration that overwrites instructions of the target process' memory space with NOP instructions.</summary>
        </member>
        <member name="M:RAMvader.CodeInjection.MemoryAlterationNOP.#ctor(RAMvader.RAMvaderTarget,RAMvader.MemoryAddress,System.Int32)">
            <summary>Constructor.</summary>
            <param name="targetIORef">
               A reference to the <see cref="T:RAMvader.RAMvaderTarget"/> object that will be used to read the target process' memory space.
               This <see cref="T:RAMvader.RAMvaderTarget"/> MUST be attached to a process, as it will be used in this constructor method to read the process'
               memory and keep a snapshot of the original bytes at the given 'targetAddress' for restoring their values,
               whenever <see cref="M:RAMvader.CodeInjection.MemoryAlterationNOP.SetEnabled``3(RAMvader.CodeInjection.Injector{``0,``1,``2},System.Boolean)"/> is called to deactivate a memory alteration.
            </param>
            <param name="targetAddress">The address of the instruction(s) that will be replaced with NOP instructions.</param>
            <param name="instructionSize">The size of the instruction(s) that will be replaced with NOP instructions.</param>
        </member>
        <member name="M:RAMvader.CodeInjection.MemoryAlterationNOP.SetEnabled``3(RAMvader.CodeInjection.Injector{``0,``1,``2},System.Boolean)">
            <summary>Called to activate or deactivate a memory alteration into the target process' memory space.</summary>
            <typeparam name="TMemoryAlterationID">The enumeration of Memory Alteration Sets used for the <see cref="T:RAMvader.CodeInjection.Injector`3" />.</typeparam>
            <typeparam name="TCodeCave">The enumeration of Code Caves used for the <see cref="T:RAMvader.CodeInjection.Injector`3" />.</typeparam>
            <typeparam name="TVariable">The enumeration of Injection Variables used for the <see cref="T:RAMvader.CodeInjection.Injector`3" />.</typeparam>
            <param name="injectorRef">A reference to an <see cref="T:RAMvader.CodeInjection.Injector`3"/> object, with which you can perform I/O operations on the target process' memory space and access related data, like values and addresses of variables and code caves.</param>
            <param name="bEnable">A flag specifying if the memory alteration should be enabled or disabled.</param>
            <returns>Returns a flag specifying if the operation was successful or not.</returns>
        </member>
        <member name="T:RAMvader.CodeInjection.MemoryAlterationPoke">
            <summary>Represents a memory alteration that overwrites instructions of the target process' memory space with custom bytes.</summary>
        </member>
        <member name="F:RAMvader.CodeInjection.MemoryAlterationPoke.m_customBytes">
            <summary>Keeps the custom bytes that will replace the target instruction(s).</summary>
        </member>
        <member name="M:RAMvader.CodeInjection.MemoryAlterationPoke.#ctor(RAMvader.RAMvaderTarget,RAMvader.MemoryAddress,System.Byte[])">
            <summary>Constructor.</summary>
            <param name="targetIORef">
               A reference to the <see cref="T:RAMvader.RAMvaderTarget"/> object that will be used to read the target process' memory space.
               This <see cref="T:RAMvader.RAMvaderTarget"/> MUST be attached to a process, as it will be used in this constructor method to read the process'
               memory and keep a snapshot of the original bytes at the given 'targetAddress' for restoring their values,
               whenever <see cref="M:RAMvader.CodeInjection.MemoryAlterationPoke.SetEnabled``3(RAMvader.CodeInjection.Injector{``0,``1,``2},System.Boolean)"/> is called to deactivate a memory alteration.
            </param>
            <param name="targetAddress">The address of the instruction(s) that will be replaced with custom bytes.</param>
            <param name="customBytes">
               The bytes which will replace the instruction(s) at the given address.
               The length of this array is used to determine the size of the instructions to be replaced at that address.
            </param>
        </member>
        <member name="M:RAMvader.CodeInjection.MemoryAlterationPoke.SetEnabled``3(RAMvader.CodeInjection.Injector{``0,``1,``2},System.Boolean)">
            <summary>Called to activate or deactivate a memory alteration into the target process' memory space.</summary>
            <typeparam name="TMemoryAlterationID">The enumeration of Memory Alteration Sets used for the <see cref="T:RAMvader.CodeInjection.Injector`3" />.</typeparam>
            <typeparam name="TCodeCave">The enumeration of Code Caves used for the <see cref="T:RAMvader.CodeInjection.Injector`3" />.</typeparam>
            <typeparam name="TVariable">The enumeration of Injection Variables used for the <see cref="T:RAMvader.CodeInjection.Injector`3" />.</typeparam>
            <param name="injectorRef">A reference to an <see cref="T:RAMvader.CodeInjection.Injector`3"/> object, with which you can perform I/O operations on the target process' memory space and access related data, like values and addresses of variables and code caves.</param>
            <param name="bEnable">A flag specifying if the memory alteration should be enabled or disabled.</param>
            <returns>Returns a flag specifying if the operation was successful or not.</returns>
        </member>
        <member name="T:RAMvader.CodeInjection.VariableDefinition">
            <summary>Keeps the metadata related to an injection variable.</summary>
        </member>
        <member name="F:RAMvader.CodeInjection.VariableDefinition.m_initialValue">
            <summary>
               Stores the initial value for the variable. Used to initialize the
               variable's value, when it is first injected into the target process'
               memory.
            </summary>
        </member>
        <member name="P:RAMvader.CodeInjection.VariableDefinition.InitialValue">
            <summary>Backed by the <see cref="F:RAMvader.CodeInjection.VariableDefinition.m_initialValue"/> field.</summary>
        </member>
        <member name="M:RAMvader.CodeInjection.VariableDefinition.#ctor(System.Object)">
            <summary>Constructor.</summary>
            <param name="initialValue">
               The initial value of the variable.
               This should be specified with structures from the basic values which are supported by
               the <see cref="T:RAMvader.CodeInjection.Injector`3"/> (Byte, Int32, UInt64, Single, Double, etc.). By providing these structures, you are both telling
               the injector about the SIZE of the injected variable and its initial value.
            </param>
            <exception cref="T:System.NullReferenceException">Thrown when the given initial value of the variable is <code>null</code>.</exception>
        </member>
        <member name="M:RAMvader.CodeInjection.VariableDefinition.GetInitialValue">
            <summary>
               Retrieves the initial value of the variable.
               When the <see cref="T:RAMvader.CodeInjection.Injector`3"/> injects the variable in
               the target process' memory space, it initializes the variable to this value.
            </summary>
            <returns>Returns the initial value of the variable.</returns>
        </member>
        <member name="M:RAMvader.CodeInjection.VariableDefinition.GetInjectionVariableType">
            <summary>
               <para>Retrieves the <see cref="T:System.Type"/> of the injection variable.</para>
               <para>
                  The <see cref="T:System.Type"/> of the injection variable is defined to be the same type as the 
                  initial value of the variable, which is passed in its definition's constructor (<see cref="M:RAMvader.CodeInjection.VariableDefinition.#ctor(System.Object)"/>).
                  Thus, another way to get the injection variable's type is by calling <see cref="M:RAMvader.CodeInjection.VariableDefinition.GetInitialValue"/> to
                  retrieve the initial value of the variable, and then calling <see cref="M:System.Object.GetType"/> on the
                  returned value.
               </para>
            </summary>
            <returns>Returns the <see cref="T:System.Type"/> of the injection variable.</returns>
        </member>
        <member name="T:RAMvader.EEndianness">
            <summary>Defines the possible endianness options which RAMvader can operate on.</summary>
        </member>
        <member name="F:RAMvader.EEndianness.evEndiannessDefault">
            <summary>A value indicating that RAMvader should operate in the same endianness as the process that RAMvader is running on.</summary>
        </member>
        <member name="F:RAMvader.EEndianness.evEndiannessLittle">
            <summary>A value indicating that RAMvader should operate in Little-Endian byte order.</summary>
        </member>
        <member name="F:RAMvader.EEndianness.evEndiannessBig">
            <summary>A value indicating that RAMvader should operate in Big-Endian byte order.</summary>
        </member>
        <member name="T:RAMvader.EPointerSize">
            <summary>Defines the supported pointer sizes for the target process.</summary>
        </member>
        <member name="F:RAMvader.EPointerSize.evPointerSizeDefault">
            <summary>
               The default pointer size configuration, where the target process' pointer size is assumed to be the same as the pointer
               size of the process which runs RAMvader. The pointer size can be retrieved through IntPtr.Size.
            </summary>
        </member>
        <member name="F:RAMvader.EPointerSize.evPointerSize32">
            <summary>Explicitly identifies a 32-bit pointer.</summary>
        </member>
        <member name="F:RAMvader.EPointerSize.evPointerSize64">
            <summary>Explicitly identifies a 64-bit pointer.</summary>
        </member>
        <member name="T:RAMvader.EDifferentPointerSizeError">
            <summary>Defines how errors with different pointer sizes are handled by the library.</summary>
        </member>
        <member name="F:RAMvader.EDifferentPointerSizeError.evThrowException">
            <summary>
               Throws an exception if the target process and the process which runs RAMvader have different pointer sizes.
               This is the default behaviour, for safety reasons.
            </summary>
        </member>
        <member name="F:RAMvader.EDifferentPointerSizeError.evSafeTruncation">
            <summary>
               If the target process and the process which uses RAMvader have different pointer sizes, operations with pointers truncate
               the pointers to 32-bits when necessary. If any data is lost during the truncation process, a <see cref="T:RAMvader.PointerDataLostException"/>
               is thrown.
            </summary>
        </member>
        <member name="F:RAMvader.EDifferentPointerSizeError.evUnsafeTruncation">
            <summary>
               If the target process and the process which uses RAMvader have different pointer sizes, operations with pointers truncate the
               pointers to 32-bits when necessary. If any data is lost during the truncation process, nothing happens. Thus, this is the less
               recommended option and should be used with caution.
            </summary>
        </member>
        <member name="T:RAMvader.EJumpInstructionType">
            <summary>Defines the types of JUMP instructions that can be generated by the <see cref="T:RAMvader.CodeInjection.Injector`3"/> class.</summary>
        </member>
        <member name="F:RAMvader.EJumpInstructionType.evJMP">
            <summary>Identifies the jump instruction: JMP ("unconditional jump).</summary>
        </member>
        <member name="F:RAMvader.EJumpInstructionType.evJA">
            <summary>Identifies the jump instruction: JA ("jump if above" - for unsigned values).</summary>
        </member>
        <member name="F:RAMvader.EJumpInstructionType.evJAE">
            <summary>Identifies the jump instruction: JAE ("jump if above or equal" - for unsigned values).</summary>
        </member>
        <member name="F:RAMvader.EJumpInstructionType.evJB">
            <summary>Identifies the jump instruction: JB ("jump if below" - for unsigned values).</summary>
        </member>
        <member name="F:RAMvader.EJumpInstructionType.evJBE">
            <summary>Identifies the jump instruction: JBE ("jump if below or equal" - for unsigned values).</summary>
        </member>
        <member name="F:RAMvader.EJumpInstructionType.evJG">
            <summary>Identifies the jump instruction: JG ("jump if greater than" - for signed values).</summary>
        </member>
        <member name="F:RAMvader.EJumpInstructionType.evJGE">
            <summary>Identifies the jump instruction: JGE ("jump if greater than or equal to" - for signed values).</summary>
        </member>
        <member name="F:RAMvader.EJumpInstructionType.evJL">
            <summary>Identifies the jump instruction: JL ("jump if less than" - for signed values).</summary>
        </member>
        <member name="F:RAMvader.EJumpInstructionType.evJLE">
            <summary>Identifies the jump instruction: JLE ("jump if less than or equal to" - for signed values).</summary>
        </member>
        <member name="F:RAMvader.EJumpInstructionType.evJE">
            <summary>Identifies the jump instruction: JE ("jump if equal").</summary>
        </member>
        <member name="F:RAMvader.EJumpInstructionType.evJNE">
            <summary>Identifies the jump instruction: JNE ("jump if not equal").</summary>
        </member>
        <member name="T:RAMvader.ModuleNotFoundException">
            <summary>
               Exception thrown when the RAMvader library fails to find a module in the
               target process' modules list.
            </summary>
        </member>
        <member name="M:RAMvader.ModuleNotFoundException.#ctor(System.String)">
            <summary>Constructor.</summary>
            <param name="moduleName">The name of the module which has not been found.</param>
        </member>
        <member name="T:RAMvader.RequiredIOException">
            <summary>Exception that is thrown when an I/O operation that was required to succeed returns a fail state.</summary>
        </member>
        <member name="M:RAMvader.RequiredIOException.#ctor(System.String)">
            <summary>Constructor.</summary>
            <param name="msg">The message associated to the exception.</param>
        </member>
        <member name="T:RAMvader.RequiredReadException">
            <summary>Exception that is thrown when an input/read operation that was required to succeed returns a fail state.</summary>
        </member>
        <member name="M:RAMvader.RequiredReadException.#ctor(System.String)">
            <summary>Constructor.</summary>
            <param name="msg">The message associated to the exception.</param>
        </member>
        <member name="T:RAMvader.RequiredWriteException">
            <summary>Exception that is thrown when an output/write operation that was required to succeed returns a fail state.</summary>
        </member>
        <member name="M:RAMvader.RequiredWriteException.#ctor(System.String)">
            <summary>Constructor.</summary>
            <param name="msg">The message associated to the exception.</param>
        </member>
        <member name="T:RAMvader.UnexpectedDataTypeSizeException">
            <summary>
               Exception thrown when the compiler reports an unexpected size for a basic type handled by the RAMvader library.
               This exception exists for safety purposes only, and should never be thrown on standard development environments.
            </summary>
        </member>
        <member name="M:RAMvader.UnexpectedDataTypeSizeException.#ctor(System.String)">
            <summary>Constructor.</summary>
            <param name="msg">The message to be associated with the exception.</param>
        </member>
        <member name="T:RAMvader.UnmatchedCodeCaveIdentifierException">
            <summary>
               Exception thrown when the identifier given for a code cave does not match the expected enumeration type of identifiers
               for code caves of an <see cref="T:RAMvader.CodeInjection.Injector`3"/>.
            </summary>
        </member>
        <member name="M:RAMvader.UnmatchedCodeCaveIdentifierException.#ctor(System.String)">
            <summary>Constructor.</summary>
            <param name="msg">The message to be associated with the exception.</param>
        </member>
        <member name="T:RAMvader.InstanceAlreadyAttachedException">
            <summary>
               Exception thrown when the user tries to attach a <see cref="T:RAMvader.RAMvaderTarget"/> instance to a process, but the instance
               is already attached to another process. Before attaching to a process, the <see cref="T:RAMvader.RAMvaderTarget"/> instance must
               be detached from any other process.
            </summary>
        </member>
        <member name="M:RAMvader.InstanceAlreadyAttachedException.#ctor(System.Diagnostics.Process)">
            <summary>Constructor.</summary>
            <param name="oldProcess">The process to which the <see cref="T:RAMvader.RAMvaderTarget"/> instance is currently attached.</param>
        </member>
        <member name="T:RAMvader.InstanceNotAttachedException">
            <summary>
               Exception thrown when a method that requires the <see cref="T:RAMvader.RAMvaderTarget"/> instance to be attached
               is called, while the <see cref="T:RAMvader.RAMvaderTarget"/> is in a "not attached" state (i.e.,
               the <see cref="T:RAMvader.RAMvaderTarget"/> hasn't been attached to any target process yet).
            </summary>
        </member>
        <member name="M:RAMvader.InstanceNotAttachedException.#ctor">
            <summary>Constructor.</summary>
        </member>
        <member name="T:RAMvader.PointerDataLostException">
            <summary>
               An exception which is thrown when trying to perform an I/O operation with pointers between
               two processes with different pointer sizes.
            </summary>
        </member>
        <member name="M:RAMvader.PointerDataLostException.#ctor(System.Boolean)">
            <summary>Constructor.</summary>
            <param name="bIsReadOperation">A flag specifying if the exception has been thrown during a read operation (true) or a write operation (false).</param>
        </member>
        <member name="T:RAMvader.AbsoluteMemoryAddress">
            <summary>
               A specialization for the <see cref="T:RAMvader.MemoryAddress"/> class, used to represent
               absolute/static/constant addresses.
            </summary>
        </member>
        <member name="F:RAMvader.AbsoluteMemoryAddress.m_realAddress">
            <summary>Represents the actual absolute/static/constant address represented by this instance.</summary>
        </member>
        <member name="M:RAMvader.AbsoluteMemoryAddress.#ctor(System.IntPtr)">
            <summary>Constructor.</summary>
            <param name="address">The absolute/static/constant address associated to this instance.</param>
        </member>
        <member name="M:RAMvader.AbsoluteMemoryAddress.#ctor(System.Int32)">
            <summary>Constructor.</summary>
            <param name="address">The absolute/static/constant address associated to this instance.</param>
        </member>
        <member name="M:RAMvader.AbsoluteMemoryAddress.#ctor(System.Int64)">
            <summary>Constructor.</summary>
            <param name="address">The absolute/static/constant address associated to this instance.</param>
        </member>
        <member name="M:RAMvader.AbsoluteMemoryAddress.GetRealAddress">
            <summary>
               Specialized by subclasses to calculate the real address associated with
               the <see cref="T:RAMvader.MemoryAddress"/> object.
            </summary>
            <returns>Returns an <see cref="T:System.IntPtr"/> representing the real/calculated address associated to the <see cref="T:RAMvader.MemoryAddress"/> instance.</returns>
        </member>
        <member name="T:RAMvader.InjectedCodeCaveMemoryAddress`3">
            <summary>
               A specialization for the <see cref="T:RAMvader.MemoryAddress"/> class, used to represent
               addresses of code caves that get injected by the <see cref="T:RAMvader.CodeInjection.Injector`3"/>
               into a target process' memory space.
            </summary>
            <typeparam name="TMemoryAlterationSetID">
               An enumerated type which specifies the identifiers for Memory Alteration Sets
               that can be enabled or disabled into the target process' memory space.
            </typeparam>
            <typeparam name="TCodeCave">An enumerated type which specifies the identifiers for code caves.</typeparam>
            <typeparam name="TVariable">
               An enumerated type which specifies the identifiers for variables to be injected at the
               target process.
            </typeparam>
        </member>
        <member name="F:RAMvader.InjectedCodeCaveMemoryAddress`3.m_injector">
            <summary>
               A reference to the <see cref="T:RAMvader.CodeInjection.Injector`3"/> which is used
               to inject the code cave into the <see cref="T:System.Diagnostics.Process"/>' address space.
            </summary>
        </member>
        <member name="F:RAMvader.InjectedCodeCaveMemoryAddress`3.m_codeCaveId">
            <summary>The identifier of the code cave whose injection address is to be retrieved.</summary>
        </member>
        <member name="M:RAMvader.InjectedCodeCaveMemoryAddress`3.#ctor(RAMvader.CodeInjection.Injector{`0,`1,`2},`1)">
            <summary>Constructor.</summary>
            <param name="injector">
               A reference to the <see cref="T:RAMvader.CodeInjection.Injector`3"/> which is used
               to inject the code cave into the <see cref="T:System.Diagnostics.Process"/>' address space.
            </param>
            <param name="codeCaveId">The identifier of the code cave whose injection address is to be retrieved.</param>
        </member>
        <member name="M:RAMvader.InjectedCodeCaveMemoryAddress`3.GetRealAddress">
            <summary>
               Specialized by subclasses to calculate the real address associated with
               the <see cref="T:RAMvader.MemoryAddress"/> object.
            </summary>
            <returns>Returns an <see cref="T:System.IntPtr"/> representing the real/calculated address associated to the <see cref="T:RAMvader.MemoryAddress"/> instance.</returns>
        </member>
        <member name="T:RAMvader.InjectedVariableMemoryAddress`3">
            <summary>
               A specialization for the <see cref="T:RAMvader.MemoryAddress"/> class, used to represent
               addresses of variables that get injected by the <see cref="T:RAMvader.CodeInjection.Injector`3"/>
               into a target process' memory space.
            </summary>
            <typeparam name="TMemoryAlterationSetID">
               An enumerated type which specifies the identifiers for Memory Alteration Sets
               that can be enabled or disabled into the target process' memory space.
            </typeparam>
            <typeparam name="TCodeCave">An enumerated type which specifies the identifiers for code caves.</typeparam>
            <typeparam name="TVariable">
               An enumerated type which specifies the identifiers for variables to be injected at the
               target process.
            </typeparam>
        </member>
        <member name="F:RAMvader.InjectedVariableMemoryAddress`3.m_injector">
            <summary>
               A reference to the <see cref="T:RAMvader.CodeInjection.Injector`3"/> which is used
               to inject the variable into the <see cref="T:System.Diagnostics.Process"/>' address space.
            </summary>
        </member>
        <member name="F:RAMvader.InjectedVariableMemoryAddress`3.m_variableId">
            <summary>The identifier of the variable whose injection address is to be retrieved.</summary>
        </member>
        <member name="M:RAMvader.InjectedVariableMemoryAddress`3.#ctor(RAMvader.CodeInjection.Injector{`0,`1,`2},`2)">
            <summary>Constructor.</summary>
            <param name="injector">
               A reference to the <see cref="T:RAMvader.CodeInjection.Injector`3"/> which is used
               to inject the code cave into the <see cref="T:System.Diagnostics.Process"/>' address space.
            </param>
            <param name="variableId">The identifier of the variable whose injection address is to be retrieved.</param>
        </member>
        <member name="M:RAMvader.InjectedVariableMemoryAddress`3.GetRealAddress">
            <summary>
               Specialized by subclasses to calculate the real address associated with
               the <see cref="T:RAMvader.MemoryAddress"/> object.
            </summary>
            <returns>Returns an <see cref="T:System.IntPtr"/> representing the real/calculated address associated to the <see cref="T:RAMvader.MemoryAddress"/> instance.</returns>
        </member>
        <member name="T:RAMvader.MemoryAddress">
            <summary>
               <para>
                  Represents a memory address for the RAMvader library.
                  Memory addresses should be READ-ONLY: once they're created, the real memory address they
                  represent internally must not be changed.
               </para>
               <para>
                  Although they're read-only, the real addresses they represent are dynamically calculated
                  when a call to <see cref="M:RAMvader.MemoryAddress.GetRealAddress"/>, and are recalculated everytime this method gets called.
                  The only exception to this rececalculation rule is for the <see cref="T:RAMvader.AbsoluteMemoryAddress"/> class,
                  which represent an absolute address that never changes (and thus is cached inside the instance of this class).
               </para>
            </summary>
        </member>
        <member name="P:RAMvader.MemoryAddress.Address">
            <summary>
               Retrieves the real/calculated address represented by the <see cref="T:RAMvader.MemoryAddress"/> object.
            </summary>
        </member>
        <member name="M:RAMvader.MemoryAddress.GetRealAddress">
            <summary>
               Specialized by subclasses to calculate the real address associated with
               the <see cref="T:RAMvader.MemoryAddress"/> object.
            </summary>
            <returns>Returns an <see cref="T:System.IntPtr"/> representing the real/calculated address associated to the <see cref="T:RAMvader.MemoryAddress"/> instance.</returns>
        </member>
        <member name="T:RAMvader.ModuleOffsetMemoryAddress">
            <summary>
               A specialization for the <see cref="T:RAMvader.MemoryAddress"/> class, used to represent
               addresses that are calculated as offsets from a given module of the process to which
               the <see cref="T:RAMvader.RAMvaderTarget"/> is attached.
            </summary>
        </member>
        <member name="F:RAMvader.ModuleOffsetMemoryAddress.m_target">
            <summary>A reference to the object used to access the target <see cref="T:System.Diagnostics.Process"/>' address space.</summary>
        </member>
        <member name="F:RAMvader.ModuleOffsetMemoryAddress.m_moduleName">
            <summary>The name of the module whose base address will be used to calculate the final (real) address.</summary>
        </member>
        <member name="F:RAMvader.ModuleOffsetMemoryAddress.m_offset">
            <summary>The offset to apply to the base of the given module in order to find the final (real) address.</summary>
        </member>
        <member name="M:RAMvader.ModuleOffsetMemoryAddress.#ctor(RAMvader.RAMvaderTarget,System.String,System.Int32)">
            <summary>Constructor.</summary>
            <param name="target">A reference to the object used to access the target <see cref="T:System.Diagnostics.Process"/>' address space.</param>
            <param name="moduleName">The name of the module whose base address will be used to calculate the final (real) address.</param>
            <param name="offset">The offset to apply to the base of the given module in order to find the final (real) address.</param>
        </member>
        <member name="M:RAMvader.ModuleOffsetMemoryAddress.GetRealAddress">
            <summary>
               Specialized by subclasses to calculate the real address associated with
               the <see cref="T:RAMvader.MemoryAddress"/> object.
            </summary>
            <returns>Returns an <see cref="T:System.IntPtr"/> representing the real/calculated address associated to the <see cref="T:RAMvader.MemoryAddress"/> instance.</returns>
        </member>
        <member name="T:RAMvader.NotifyPropertyChangedAdapter">
            <summary>
               An adapter class to make the implementation of the INotifyPropertyChanged interface easier
               for any class willing to provide that implementation.
            </summary>
        </member>
        <member name="E:RAMvader.NotifyPropertyChangedAdapter.PropertyChanged">
            <summary>Used for implementing the <see cref="T:System.ComponentModel.INotifyPropertyChanged"/> interface.</summary>
        </member>
        <member name="M:RAMvader.NotifyPropertyChangedAdapter.SendPropertyChangedNotification(System.String)">
            <summary>
               This method should be called inside PROPERTY SETTER METHODS to notify
               listeners of the "property changed" event that the property has been updated.
            </summary>
            <param name="propertyName">
               This parameter is automatically filled with the name of the
               updated property by the compiler, as long as it is called with no parameters
               inside a property-setter method.
            </param>
        </member>
        <member name="T:RAMvader.RAMvaderException">
            <summary>The base class for all exceptions from the RAMvader library.</summary>
        </member>
        <member name="M:RAMvader.RAMvaderException.#ctor(System.String)">
            <summary>Constructor.</summary>
            <param name="msg">The message associated to the exception.</param>
        </member>
        <member name="T:RAMvader.RAMvaderTarget">
            <summary>
               RAMvader library's core class.
               Instances of this class are able to "attach" to processes and execute reading and writing operations in their memory spaces.
            </summary>
        </member>
        <member name="F:RAMvader.RAMvaderTarget.SUPPORTED_DATA_TYPES_SIZE">
            <summary>
               A dictionary containing both all basic data types supported by the RAMvader library and their respective
               sizes. Notice, though, that the IntPtr type IS supported by the library but is not listed in this Dictionary,
               because it is treated in a special way by the library, due to its variant-size nature.
            </summary>
        </member>
        <member name="F:RAMvader.RAMvaderTarget.m_process">
            <summary>The Process to which this instance is currently attached.</summary>
        </member>
        <member name="F:RAMvader.RAMvaderTarget.m_targetProcessHandle">
            <summary>The low-level Handle to the target process we are attached to.</summary>
        </member>
        <member name="F:RAMvader.RAMvaderTarget.m_targetProcessEndianness">
            <summary>The current endianness that the <see cref="T:RAMvader.RAMvaderTarget"/> is operating on. The default is
            for RAMvader to assume the target process runs in the same endianness as the process that
            is running RAMvader.</summary>
        </member>
        <member name="F:RAMvader.RAMvaderTarget.m_targetPointerSize">
            <summary>Keeps the pointer size of the target process. Default configuration is to use
            the same pointer size of the process which runs RAMvader.</summary>
        </member>
        <member name="F:RAMvader.RAMvaderTarget.m_diffPointerSizeError">
            <summary>Determines the type of error handling which is used when the target process runs with a
            different pointer size configuration, as compared to the process which runs RAMvader.</summary>
        </member>
        <member name="F:RAMvader.RAMvaderTarget.m_modulesBaseAddresses">
            <summary>
               For each of the modules of the <see cref="T:System.Diagnostics.Process"/> this instance is attached to,
               maps the name of the module to its base address.
               This map might be updated by a call to <see cref="M:RAMvader.RAMvaderTarget.RefreshTargetProcessModulesBaseAddresses"/>
            </summary>
        </member>
        <member name="P:RAMvader.RAMvaderTarget.TargetProcess">
            <summary>
               The Process object which this RAMvaderTarget instance is attached to.
               The <see cref="P:RAMvader.RAMvaderTarget.TargetProcess"/> property can only be changed by calls to <see cref="M:RAMvader.RAMvaderTarget.AttachToProcess(System.Diagnostics.Process)"/>
               or <see cref="M:RAMvader.RAMvaderTarget.DetachFromProcess"/>.
               Backed by the <see cref="F:RAMvader.RAMvaderTarget.m_process"/> field.
            </summary>
        </member>
        <member name="P:RAMvader.RAMvaderTarget.ProcessHandle">
            <summary>
               The handle to the Process object which this RAMvaderTarget instance is attached to.
               The <see cref="P:RAMvader.RAMvaderTarget.ProcessHandle"/> property can only be changed by calls to <see cref="M:RAMvader.RAMvaderTarget.AttachToProcess(System.Diagnostics.Process)"/> or <see cref="M:RAMvader.RAMvaderTarget.DetachFromProcess"/>.
               Backed by the <see cref="F:RAMvader.RAMvaderTarget.m_targetProcessHandle"/> field.
            </summary>
        </member>
        <member name="P:RAMvader.RAMvaderTarget.Attached">
            <summary>
               A flag specifying if this instance is currently attached to a target process.
               Returns the same result as the <see cref="M:RAMvader.RAMvaderTarget.IsAttached"/> method.
            </summary>
        </member>
        <member name="P:RAMvader.RAMvaderTarget.TargetProcessEndianness">
            <summary>
               The endianness configured for the target process.
               This property can also be accessed through the methods <see cref="M:RAMvader.RAMvaderTarget.SetTargetEndianness(RAMvader.EEndianness)"/>
               and <see cref="M:RAMvader.RAMvaderTarget.GetTargetEndianness"/>.
               Backed by the <see cref="F:RAMvader.RAMvaderTarget.m_targetProcessEndianness"/> field.
            </summary>
        </member>
        <member name="P:RAMvader.RAMvaderTarget.ActualTargetProcessEndianness">
            <summary>
               The actual endianness that the <see cref="T:RAMvader.RAMvaderTarget"/> instance is currently assuming that
               the target process is using. This is the same value returned by
               the <see cref="M:RAMvader.RAMvaderTarget.GetActualTargetEndianness"/> method - see its description for more details.
            </summary>
        </member>
        <member name="P:RAMvader.RAMvaderTarget.TargetPointerSize">
            <summary>
               The pointer size configured for the target process.
               This property can also be accessed through the methods <see cref="M:RAMvader.RAMvaderTarget.SetTargetPointerSize(RAMvader.EPointerSize)"/>
               and <see cref="M:RAMvader.RAMvaderTarget.GetTargetPointerSize"/>.
               Backed by the <see cref="F:RAMvader.RAMvaderTarget.m_targetPointerSize"/> field.
            </summary>
        </member>
        <member name="P:RAMvader.RAMvaderTarget.ActualTargetPointerSize">
            <summary>
               The actual pointer size that the <see cref="T:RAMvader.RAMvaderTarget"/> instance is currently assuming that
               the target process is using. This is the same value returned by
               the <see cref="M:RAMvader.RAMvaderTarget.GetActualTargetPointerSize"/> method - see its description for more details.
            </summary>
        </member>
        <member name="P:RAMvader.RAMvaderTarget.PointerSizeErrorHandling">
            <summary>
               The type of error handling which is used when the target process runs with a different
               pointer size configuration, as compared to the process which runs RAMvader.
               This property can also be accessed through the methods <see cref="M:RAMvader.RAMvaderTarget.SetTargetPointerSizeErrorHandling(RAMvader.EDifferentPointerSizeError)"/>
               and <see cref="M:RAMvader.RAMvaderTarget.GetTargetPointerSizeErrorHandling"/>.
               Backed by the <see cref="F:RAMvader.RAMvaderTarget.m_diffPointerSizeError"/> field.
            </summary>
        </member>
        <member name="T:RAMvader.RAMvaderTarget.AttachedEventHandler">
            <summary>Delegate used for handling the event which is fired when the <see cref="T:RAMvader.RAMvaderTarget"/> object is attached to a process.</summary>
            <param name="sender">The object that sent the event.</param>
            <param name="args">The arguments (data) of the event.</param>
        </member>
        <member name="T:RAMvader.RAMvaderTarget.DetachedEventHandler">
            <summary>Delegate used for handling the event which is fired when the <see cref="T:RAMvader.RAMvaderTarget"/> object is detached from a process.</summary>
            <param name="sender">The object that sent the event.</param>
            <param name="args">The arguments (data) of the event.</param>
        </member>
        <member name="E:RAMvader.RAMvaderTarget.AttachedEvent">
            <summary>Handles the event that gets fired when the <see cref="T:RAMvader.RAMvaderTarget"/> gets attached to a process.</summary>
        </member>
        <member name="E:RAMvader.RAMvaderTarget.DetachedEvent">
            <summary>Handles the event that gets fired when the <see cref="T:RAMvader.RAMvaderTarget"/> gets detached from a process.</summary>
        </member>
        <member name="M:RAMvader.RAMvaderTarget.GetRAMvaderPointerSize">
            <summary>Retrieves the pointer size for the process which runs RAMvader.</summary>
            <returns>Returns a <see cref="T:RAMvader.EPointerSize"/> value, specifying the pointer size of the process.</returns>
        </member>
        <member name="M:RAMvader.RAMvaderTarget.GetValueAsBytesArray(System.Object,RAMvader.EEndianness,RAMvader.EPointerSize,RAMvader.EDifferentPointerSizeError)">
            <summary>Utility method for retrieving a given value as an array of bytes, respecting the specified endianness.</summary>
            <param name="value">The value to be retrieved as a sequence of bytes.</param>
            <param name="endianness">The endianness to be used when retrieving the sequence of bytes.</param>
            <param name="pointerSize">
               The size of pointer to be used when retrieving the sequence of bytes.
               That parameter is only used when retrieving the bytes representation of IntPtr values.
            </param>
            <param name="diffPointerSizeError">
               The policy for handling errors regarding different sizes of pointers between RAMvader process'
               pointers and the pointers size defined by the "pointerSize" parameter. That parameter is only used when retrieving the
               bytes representation of IntPtr values.
            </param>
            <returns>Returns a sequence of bytes representing the value in the given endianness (and pointer sizes, if applicable).</returns>
        </member>
        <member name="M:RAMvader.RAMvaderTarget.RevertArrayOnEndiannessDifference(System.Byte[],RAMvader.EEndianness)">
            <summary>Reverts the given array of bytes, if the specified endianness is different from the endianness
            used by the process which runs RAMvader.</summary>
            <param name="bytesArray">The array to be set to the target process' endianness.</param>
            <param name="endianness">The endianness to compare agains the RAMvader process' endianness.</param>
        </member>
        <member name="M:RAMvader.RAMvaderTarget.IsDataTypeSupported(System.Type)">
            <summary>Verifies if a given data type is supported by the RAMvader library.</summary>
            <param name="type">The type to be verified.</param>
            <returns>Returns a flag indicating if the given type is supported by the RAMvader library.</returns>
        </member>
        <member name="M:RAMvader.RAMvaderTarget.GetSupportedDataTypeSizeInBytes(System.Type)">
            <summary>
               <para>
                  Retrieves the size (as considered by the RAMvader library) of a specific data type that is
                  supported by the library, given in bytes.
               </para>
               <para>ATTENTION: this method does NOT support the <see cref="T:System.IntPtr"/> (see remarks).</para>
            </summary>
            <param name="type">The type to be verified.</param>
            <returns>Retrieves the size of the type, in bytes, as considered by the RAMvader library.</returns>
            <exception cref="T:RAMvader.UnsupportedDataTypeException">
               Thrown when the given data type is <see cref="T:System.IntPtr"/> or when the given type is not supported by the
               library.
               To check if a type is supported (except for the <see cref="T:System.IntPtr"/> type), please refer
               to <see cref="M:RAMvader.RAMvaderTarget.IsDataTypeSupported(System.Type)"/>.
            </exception>
            <remarks>
               The <see cref="T:System.IntPtr"/> type is not supported by this method, as it is a type whose size changes might
               change depending on the process being a 32-bit or 64-bit process.
               To retrieve the size considered for an <see cref="T:System.IntPtr"/>, you must use the
               method <see cref="M:RAMvader.RAMvaderTarget.GetActualTargetPointerSizeInBytes"/>, which requires an
               already-configured <see cref="T:RAMvader.RAMvaderTarget"/> object.
            </remarks>
            
        </member>
        <member name="M:RAMvader.RAMvaderTarget.#ctor">
            <summary>Constructor.</summary>
        </member>
        <member name="M:RAMvader.RAMvaderTarget.Finalize">
            <summary>Destructor.</summary>
        </member>
        <member name="M:RAMvader.RAMvaderTarget.SetTargetEndianness(RAMvader.EEndianness)">
            <summary>
               Makes the <see cref="T:RAMvader.RAMvaderTarget"/> instance assume that the target process is using a specific endianness to store its
               values. The default endianness assumed by a <see cref="T:RAMvader.RAMvaderTarget"/> instance is the same endianness as the process that is
               running RAMvader.
            </summary>
            <param name="endianness">The new endianness to be assumed as the target process' endianness.</param>
            <seealso cref="M:RAMvader.RAMvaderTarget.GetTargetEndianness"/>
        </member>
        <member name="M:RAMvader.RAMvaderTarget.GetTargetEndianness">
            <summary>Retrieves the endianness that the <see cref="T:RAMvader.RAMvaderTarget"/> instance is currently assuming that the target process is using.</summary>
            <returns>Returns the (assumed) target process' endianness.</returns>
            <seealso cref="M:RAMvader.RAMvaderTarget.SetTargetEndianness(RAMvader.EEndianness)"/>
        </member>
        <member name="M:RAMvader.RAMvaderTarget.GetActualTargetEndianness">
            <summary>
               Retrieves the actual endianness that the <see cref="T:RAMvader.RAMvaderTarget"/> instance is currently assuming that the target process is using.
               This method converts the <see cref="F:RAMvader.EEndianness.evEndiannessDefault"/> value into either <see cref="F:RAMvader.EEndianness.evEndiannessBig"/> or
               <see cref="F:RAMvader.EEndianness.evEndiannessLittle"/>.
            </summary>
            <returns>Returns the (assumed) target process' endianness.</returns>
            <seealso cref="M:RAMvader.RAMvaderTarget.SetTargetEndianness(RAMvader.EEndianness)"/>
        </member>
        <member name="M:RAMvader.RAMvaderTarget.SetTargetPointerSize(RAMvader.EPointerSize)">
            <summary>
               Makes the <see cref="T:RAMvader.RAMvaderTarget"/> instance assume that the target process is using a specific pointer size (32 or 64 bits)
               configuration. The default pointer size assumed by a <see cref="T:RAMvader.RAMvaderTarget"/> instance is the same pointer size as the process
               that is running RAMvader.
            </summary>
            <param name="pointerSize">The new pointer size to be assumed for the target process.</param>
            <seealso cref="M:RAMvader.RAMvaderTarget.GetTargetPointerSize"/>
        </member>
        <member name="M:RAMvader.RAMvaderTarget.GetTargetPointerSize">
            <summary>Retrieves the pointer size that the <see cref="T:RAMvader.RAMvaderTarget"/> instance is currently assuming
            that the target process is using.</summary>
            <returns>Returns the (assumed) target process' pointer size.</returns>
            <seealso cref="M:RAMvader.RAMvaderTarget.SetTargetPointerSize(RAMvader.EPointerSize)"/>
        </member>
        <member name="M:RAMvader.RAMvaderTarget.GetActualTargetPointerSize">
            <summary>
               Retrieves the actual pointer size that the <see cref="T:RAMvader.RAMvaderTarget"/> instance is currently assuming that the target process is using.
               This method converts the <see cref="F:RAMvader.EPointerSize.evPointerSizeDefault"/> value into either <see cref="F:RAMvader.EPointerSize.evPointerSize32"/>
               or <see cref="F:RAMvader.EPointerSize.evPointerSize64"/>.
            </summary>
            <returns>Returns the (assumed) target process' pointer size.</returns>
            <seealso cref="M:RAMvader.RAMvaderTarget.SetTargetPointerSize(RAMvader.EPointerSize)"/>
        </member>
        <member name="M:RAMvader.RAMvaderTarget.GetActualTargetPointerSizeInBytes">
            <summary>
               Calls the <see cref="M:RAMvader.RAMvaderTarget.GetActualTargetPointerSize"/> method and converts its returned value into
               its corresponding number of bytes.
            </summary>
            <returns>Returns the number of bytes that represents the return value of <see cref="M:RAMvader.RAMvaderTarget.GetActualTargetPointerSize"/>.</returns>
            <seealso cref="M:RAMvader.RAMvaderTarget.GetActualTargetPointerSize"/>
        </member>
        <member name="M:RAMvader.RAMvaderTarget.SetTargetPointerSizeErrorHandling(RAMvader.EDifferentPointerSizeError)">
            <summary>Defines how to handle errors related to different pointer sizes between the target process and the process which runs the RAMvader library.</summary>
            <param name="pointerSizeErrorHandling">How different pointer-size-related errors are to be handled.</param>
            <seealso cref="M:RAMvader.RAMvaderTarget.GetTargetPointerSizeErrorHandling"/>
        </member>
        <member name="M:RAMvader.RAMvaderTarget.GetTargetPointerSizeErrorHandling">
            <summary>Retrieves the pointer size that the <see cref="T:RAMvader.RAMvaderTarget"/> instance is currently assuming that the target process is using.</summary>
            <returns>Returns the (assumed) target process' pointer size.</returns>
            <seealso cref="M:RAMvader.RAMvaderTarget.SetTargetPointerSizeErrorHandling(RAMvader.EDifferentPointerSizeError)"/>
        </member>
        <member name="M:RAMvader.RAMvaderTarget.RevertArrayOnEndiannessDifference(System.Byte[])">
            <summary>
               Reverts the given array of bytes, if the target process' endianness is different
               from the endianness used by the process which runs RAMvader.
               The target process' endianness can be configured through the <see cref="M:RAMvader.RAMvaderTarget.SetTargetEndianness(RAMvader.EEndianness)"/> method.
            </summary>
            <param name="bytesArray">The array to be set to the target process' endianness.</param>
        </member>
        <member name="M:RAMvader.RAMvaderTarget.AttachToProcess(System.Diagnostics.Process)">
            <summary>Sets the target Process to which the instance needs to be attached.</summary>
            <param name="targetProcess">The target process.</param>
            <returns>Returns true in case of success, false in case of failure.</returns>
            <exception cref="T:RAMvader.InstanceAlreadyAttachedException">
               Indicates there is a Process currently attached to that <see cref="T:RAMvader.RAMvaderTarget"/> object. You must detach the
               instance from the Process by calling <see cref="M:RAMvader.RAMvaderTarget.DetachFromProcess"/> before trying to attach to another Process.
            </exception>
        </member>
        <member name="M:RAMvader.RAMvaderTarget.DetachFromProcess">
            <summary>Detaches this instance from its target process.</summary>
            <returns>
               Returns true if the instance detached successfully.
               Returns false if something went wrong when detaching from the target process.
            </returns>
            <exception cref="T:RAMvader.InstanceNotAttachedException">Indicates this instance of the <see cref="T:RAMvader.RAMvaderTarget"/> class is currently not attached to any Process.</exception>
        </member>
        <member name="M:RAMvader.RAMvaderTarget.GetAttachedProcess">
            <summary>Retrieves the Process to which this instance is attached.</summary>
            <returns>
               Returns a Process object, indicating the process to which this instance is attached.
               If the instance is not attached to any process, this method returns null.
            </returns>
        </member>
        <member name="M:RAMvader.RAMvaderTarget.IsAttached">
            <summary>
               Verify if the <see cref="T:RAMvader.RAMvaderTarget"/> is currently attached to any Process.
               This is just a shorthand method for checking if <see cref="M:RAMvader.RAMvaderTarget.GetAttachedProcess"/> returns a null value.
            </summary>
            <returns>Returns a flag indicating if the <see cref="T:RAMvader.RAMvaderTarget"/> instance is currently attached to any process.</returns>
        </member>
        <member name="M:RAMvader.RAMvaderTarget.RefreshTargetProcessModulesBaseAddresses">
            <summary>
               Refreshes the internal data which keeps the base addresses of each module of the <see cref="T:System.Diagnostics.Process"/> this instance is currently attached to.
               If new modules have been loaded by the target process, this method should be called to update the internal data about these new modules, if you need to use that data.
            </summary>
        </member>
        <member name="M:RAMvader.RAMvaderTarget.GetTargetProcessModuleBaseAddress(System.String)">
            <summary>Retrieves the base address of the given target process' module (<see cref="T:System.Diagnostics.ProcessModule"/>).</summary>
            <param name="moduleName">The name of the module of the target process whose base address is to be retrieved.</param>
            <returns>
               In case of success, returns the base address of the process' module whose name has been specified.
               Otherwise (e.g., there is no module with the given name in the target process' list of modules, or in case of any error), this method returns <see cref="F:System.IntPtr.Zero"/>.
            </returns>
        </member>
        <member name="M:RAMvader.RAMvaderTarget.GetValueAsBytesArrayInTargetProcess(System.Object)">
            <summary>
               Retrives a byte array representing the given numeric value as it would appear into
               the target process' memory space (considering its endianness).
            </summary>
            <param name="objVal">
               An Object representing the value to be converted to its (endianness correct) bytes array representation.
               This object should be one of the basic data types supported by the RAMvader library.
            </param>
            <returns>
               Returns an array of bytes representing the given value as it would be stored into the target process' memory,
               considering the target process' endianness configurations.
            </returns>
        </member>
        <member name="M:RAMvader.RAMvaderTarget.WriteToTarget(RAMvader.MemoryAddress,System.Byte[])">
            <summary>
               Writes a Byte Array into the target process' memory.
               All other writing methods convert their corresponding input data to a byte sequence
               and then call this method to execute the actual writing operation.
            </summary>
            <param name="address">The address on the target process' memory where the data is to be written.</param>
            <param name="writeData">The data to be written to the target process.</param>
            <returns>Returns true in case of success, false in case of failure.</returns>
        </member>
        <member name="M:RAMvader.RAMvaderTarget.WriteToTarget(RAMvader.MemoryAddress,System.Object)">
            <summary>Writes a value into the target process' memory.</summary>
            <param name="address">The address on the target process' memory where the data is to be written.</param>
            <param name="writeData">
               The data to be written to the target process.
               This data must be one of the basic data types supported by the RAMvader library.
            </param>
            <returns>Returns true in case of success, false in case of failure.</returns>
        </member>
        <member name="M:RAMvader.RAMvaderTarget.ReadFromTarget(RAMvader.MemoryAddress,System.Byte[])">
            <summary>
               Reads a sequence of bytes from the target process' memory, filling the given output
               array with the read bytes. All other reading methods call this method to read the desired
               data from the target process, and convert the returned bytes into the target data type.
            </summary>
            <param name="address">The address on the target process' memory where the data will be read from.</param>
            <param name="outDestiny">
               The destiny buffer, where the read data will be copied to. The number of elements in the passed
               array determines the number of bytes that will be read from the target process.
            </param>
            <returns>Returns true in case of success, false in case of failure.</returns>
        </member>
        <member name="M:RAMvader.RAMvaderTarget.ReadFromTarget(RAMvader.MemoryAddress,System.Type,System.Object@)">
            <summary>Reads a value from the target process' memory, given the type of the object to be read.</summary>
            <param name="address">The address on the target process' memory where the data will be read from.</param>
            <param name="typeToRead">The type to be read from the target process' memory space.</param>
            <param name="outDestiny">
               The result of the reading will be stored in this variable.
               The output data will be one of the basic data types supported by the RAMvader library.
            </param>
            <returns>Returns true in case of success, false in case of failure.</returns>
        </member>
        <member name="M:RAMvader.RAMvaderTarget.ReadFromTarget``1(RAMvader.MemoryAddress,``0@)">
            <summary>Reads a value from the target process' memory.</summary>
            <typeparam name="T">The data type expected to be read from the target process' memory space.</typeparam>
            <param name="address">The address on the target process' memory where the data will be read from.</param>
            <param name="outDestiny">
               The result of the reading will be stored in this variable.
               The referenced variable's data must be one of the basic data types supported by the RAMvader library.
            </param>
            <returns>Returns true in case of success, false in case of failure.</returns>
        </member>
        <member name="T:RAMvader.UnsupportedDataTypeException">
            <summary>
               An exception which is thrown when the user tries to perform a read or write operation using
               a data type that is not supported by the library.
            </summary>
        </member>
        <member name="M:RAMvader.UnsupportedDataTypeException.#ctor(System.Type)">
            <summary>Constructor.</summary>
            <param name="dataType">The data type for which RAMvader does not offer support to.</param>
        </member>
        <member name="T:RAMvader.UnsupportedPointerSizeException">
            <summary>An exception which is thrown when the user tries to attach a 32-bits process to a 64-bits target process.</summary>
        </member>
        <member name="M:RAMvader.UnsupportedPointerSizeException.#ctor(System.String)">
            <summary>Constructor.</summary>
            <param name="msg">The message to be associated with the exception.</param>
        </member>
        <member name="T:RAMvader.WinAPI">
            <summary>This class is an interface that provides access to the Windows API.</summary>
        </member>
        <member name="T:RAMvader.WinAPI.ProcessAccessFlags">
            <summary>Flags used to determine the allowed access to a process.</summary>
        </member>
        <member name="F:RAMvader.WinAPI.ProcessAccessFlags.All">
            <summary>Identifies the "PROCESS_ALL_ACCESS" process access right from the Windows API.</summary>
        </member>
        <member name="F:RAMvader.WinAPI.ProcessAccessFlags.Terminate">
            <summary>Identifies the "PROCESS_TERMINATE" process access right from the Windows API.</summary>
        </member>
        <member name="F:RAMvader.WinAPI.ProcessAccessFlags.CreateThread">
            <summary>Identifies the "PROCESS_CREATE_THREAD" process access right from the Windows API.</summary>
        </member>
        <member name="F:RAMvader.WinAPI.ProcessAccessFlags.VMOperation">
            <summary>Identifies the "PROCESS_VM_OPERATION" process access right from the Windows API.</summary>
        </member>
        <member name="F:RAMvader.WinAPI.ProcessAccessFlags.VMRead">
            <summary>Identifies the "PROCESS_VM_READ" process access right from the Windows API.</summary>
        </member>
        <member name="F:RAMvader.WinAPI.ProcessAccessFlags.VMWrite">
            <summary>Identifies the "PROCESS_VM_WRITE" process access right from the Windows API.</summary>
        </member>
        <member name="F:RAMvader.WinAPI.ProcessAccessFlags.DupHandle">
            <summary>Identifies the "PROCESS_DUP_HANDLE" process access right from the Windows API.</summary>
        </member>
        <member name="F:RAMvader.WinAPI.ProcessAccessFlags.SetInformation">
            <summary>Identifies the "PROCESS_SET_INFORMATION" process access right from the Windows API.</summary>
        </member>
        <member name="F:RAMvader.WinAPI.ProcessAccessFlags.QueryInformation">
            <summary>Identifies the "PROCESS_QUERY_INFORMATION" process access right from the Windows API.</summary>
        </member>
        <member name="F:RAMvader.WinAPI.ProcessAccessFlags.Synchronize">
            <summary>Identifies the "SYNCHRONIZE" process access right from the Windows API.</summary>
        </member>
        <member name="T:RAMvader.WinAPI.AllocationType">
            <summary>Flags used for determining the type of memory allocation in the function VirtualAllocEx.</summary>
        </member>
        <member name="F:RAMvader.WinAPI.AllocationType.Commit">
            <summary>Identifies the "MEM_COMMIT" memory allocation type from the Windows API.</summary>
        </member>
        <member name="F:RAMvader.WinAPI.AllocationType.Reserve">
            <summary>Identifies the "MEM_RESERVE" memory allocation type from the Windows API.</summary>
        </member>
        <member name="F:RAMvader.WinAPI.AllocationType.Decommit">
            <summary>Identifies the "MEM_DECOMMIT" memory freeing type from the Windows API.</summary>
        </member>
        <member name="F:RAMvader.WinAPI.AllocationType.Release">
            <summary>Identifies the "MEM_RELEASE" memory freeing type from the Windows API.</summary>
        </member>
        <member name="F:RAMvader.WinAPI.AllocationType.Reset">
            <summary>Identifies the "MEM_RESET" memory allocation type from the Windows API.</summary>
        </member>
        <member name="F:RAMvader.WinAPI.AllocationType.Physical">
            <summary>Identifies the "MEM_PHYSICAL" memory allocation type from the Windows API.</summary>
        </member>
        <member name="F:RAMvader.WinAPI.AllocationType.TopDown">
            <summary>Identifies the "MEM_TOP_DOWN" memory allocation type from the Windows API.</summary>
        </member>
        <member name="F:RAMvader.WinAPI.AllocationType.WriteWatch">
            <summary>Identifies the "MEM_WRITE_WATCH" memory allocation type from the Windows API.</summary>
        </member>
        <member name="F:RAMvader.WinAPI.AllocationType.LargePages">
            <summary>Identifies the "MEM_LARGE_PAGES" memory allocation type from the Windows API.</summary>
        </member>
        <member name="T:RAMvader.WinAPI.MemoryProtection">
            <summary>Flags determining the type of memory protection for a region of allocated pages.</summary>
        </member>
        <member name="F:RAMvader.WinAPI.MemoryProtection.Execute">
            <summary>Identifies the "PAGE_EXECUTE" page protection type from the Windows API.</summary>
        </member>
        <member name="F:RAMvader.WinAPI.MemoryProtection.ExecuteRead">
            <summary>Identifies the "PAGE_EXECUTE_READ" page protection type from the Windows API.</summary>
        </member>
        <member name="F:RAMvader.WinAPI.MemoryProtection.ExecuteReadWrite">
            <summary>Identifies the "PAGE_EXECUTE_READWRITE" page protection type from the Windows API.</summary>
        </member>
        <member name="F:RAMvader.WinAPI.MemoryProtection.ExecuteWriteCopy">
            <summary>Identifies the "PAGE_EXECUTE_WRITECOPY" page protection type from the Windows API.</summary>
        </member>
        <member name="F:RAMvader.WinAPI.MemoryProtection.NoAccess">
            <summary>Identifies the "PAGE_NOACCESS" page protection type from the Windows API.</summary>
        </member>
        <member name="F:RAMvader.WinAPI.MemoryProtection.ReadOnly">
            <summary>Identifies the "PAGE_READONLY" page protection type from the Windows API.</summary>
        </member>
        <member name="F:RAMvader.WinAPI.MemoryProtection.ReadWrite">
            <summary>Identifies the "PAGE_READWRITE" page protection type from the Windows API.</summary>
        </member>
        <member name="F:RAMvader.WinAPI.MemoryProtection.WriteCopy">
            <summary>Identifies the "PAGE_WRITECOPY" page protection type from the Windows API.</summary>
        </member>
        <member name="F:RAMvader.WinAPI.MemoryProtection.GuardModifierflag">
            <summary>Identifies the "PAGE_GUARD" page protection type modifier from the Windows API.</summary>
        </member>
        <member name="F:RAMvader.WinAPI.MemoryProtection.NoCacheModifierflag">
            <summary>Identifies the "PAGE_NOCACHE" page protection type modifier from the Windows API.</summary>
        </member>
        <member name="F:RAMvader.WinAPI.MemoryProtection.WriteCombineModifierflag">
            <summary>Identifies the "PAGE_WRITECOMBINE" page protection type modifier from the Windows API.</summary>
        </member>
        <member name="T:RAMvader.WinAPI.FreeType">
            <summary>Flags used for freeing allocated memory, through the VirtualFreeEx function.</summary>
        </member>
        <member name="F:RAMvader.WinAPI.FreeType.Decommit">
            <summary>Identifies the "MEM_DECOMMIT" memory region freeing type from the Windows API.</summary>
        </member>
        <member name="F:RAMvader.WinAPI.FreeType.Release">
            <summary>Identifies the "MEM_RELEASE" memory region freeing type from the Windows API.</summary>
        </member>
        <member name="M:RAMvader.WinAPI.OpenProcess(RAMvader.WinAPI.ProcessAccessFlags,System.Boolean,System.Int32)">
            <summary>Kernel32: OpenProcess function.</summary>
        </member>
        <member name="M:RAMvader.WinAPI.CloseHandle(System.IntPtr)">
            <summary>Kernel32: CloseHandle function.</summary>
        </member>
        <member name="M:RAMvader.WinAPI.VirtualAllocEx(System.IntPtr,System.IntPtr,System.UInt32,RAMvader.WinAPI.AllocationType,RAMvader.WinAPI.MemoryProtection)">
            <summary>Kernel32: VirtualAllocEx function.</summary>
        </member>
        <member name="M:RAMvader.WinAPI.VirtualFreeEx(System.IntPtr,System.IntPtr,System.Int32,RAMvader.WinAPI.FreeType)">
            <summary>Kernel32: VirtualFreeEx function.</summary>
        </member>
        <member name="M:RAMvader.WinAPI.WriteProcessMemory(System.IntPtr,System.IntPtr,System.Byte[],System.Int32,System.IntPtr@)">
            <summary>Kernel32: WriteProcessMemory function.</summary>
        </member>
        <member name="M:RAMvader.WinAPI.ReadProcessMemory(System.IntPtr,System.IntPtr,System.Byte[],System.Int32,System.IntPtr@)">
            <summary>Kernel32: ReadProcessMemory function.</summary>
        </member>
    </members>
</doc>
